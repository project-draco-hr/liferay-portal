{
  if (hasGeneratedTag(content)) {
    return content;
  }
  String className=file.getName();
  int pos=className.lastIndexOf(CharPool.PERIOD);
  className=className.substring(0,pos);
  String packagePath=ToolsUtil.getPackagePath(file);
  if (!content.contains("package " + packagePath + StringPool.SEMICOLON)) {
    processErrorMessage(fileName,"Incorrect package path: " + fileName);
  }
  if (packagePath.endsWith(".model")) {
    if (content.contains("extends " + className + "Model")) {
      return content;
    }
  }
  String newContent=trimContent(content,false);
  if (newContent.contains("$\n */")) {
    processErrorMessage(fileName,"*: " + fileName);
    newContent=StringUtil.replace(newContent,"$\n */","$\n *\n */");
  }
  newContent=fixCopyright(newContent,absolutePath,fileName);
  if (newContent.contains(className + ".java.html")) {
    processErrorMessage(fileName,"Java2HTML: " + fileName);
  }
  if (newContent.contains(" * @author Raymond Aug") && !newContent.contains(" * @author Raymond Aug\u00e9")) {
    newContent=newContent.replaceFirst("Raymond Aug.++","Raymond Aug\u00e9");
    processErrorMessage(fileName,"UTF-8: " + fileName);
  }
  if (!newContent.contains(" * @author ")) {
    processErrorMessage(fileName,"Missing author: " + fileName);
  }
  newContent=fixDataAccessConnection(className,newContent);
  newContent=fixSessionKey(fileName,newContent,sessionKeyPattern);
  newContent=StringUtil.replace(newContent,new String[]{"com.liferay.portal.PortalException","com.liferay.portal.SystemException","com.liferay.util.LocalizationUtil"},new String[]{"com.liferay.portal.kernel.exception.PortalException","com.liferay.portal.kernel.exception.SystemException","com.liferay.portal.kernel.util.LocalizationUtil"});
  newContent=StringUtil.replace(newContent," final static "," static final ");
  newContent=fixCompatClassImports(absolutePath,newContent);
  ImportsFormatter importsFormatter=new JavaImportsFormatter();
  newContent=importsFormatter.format(newContent,packagePath,className);
  newContent=StringUtil.replace(newContent,new String[]{";\n/**","\t/*\n\t *",";;\n","\n/**\n *\n *"},new String[]{";\n\n/**","\t/**\n\t *",";\n","\n/**\n *"});
  newContent=fixMissingEmptyLines(newContent);
  newContent=fixRedundantEmptyLines(newContent);
  while (true) {
    Matcher matcher=_incorrectLineBreakPattern1.matcher(newContent);
    if (matcher.find()) {
      newContent=StringUtil.replaceFirst(newContent,StringPool.NEW_LINE,StringPool.BLANK,matcher.start());
      continue;
    }
    matcher=_incorrectLineBreakPattern2.matcher(newContent);
    if (matcher.find()) {
      newContent=StringUtil.replaceFirst(newContent,StringPool.NEW_LINE,StringPool.BLANK,matcher.start());
      continue;
    }
    matcher=_incorrectLineBreakPattern4.matcher(newContent);
    if (matcher.find()) {
      String matchingLine=matcher.group(2);
      if (!matchingLine.startsWith(StringPool.DOUBLE_SLASH) && !matchingLine.startsWith(StringPool.STAR)) {
        newContent=StringUtil.replaceFirst(newContent,matcher.group(3),"\n" + matcher.group(1) + "}\n",matcher.start(3) - 1);
        continue;
      }
    }
    matcher=_redundantCommaPattern.matcher(newContent);
    if (matcher.find()) {
      newContent=StringUtil.replaceFirst(newContent,StringPool.COMMA,StringPool.BLANK,matcher.start());
      continue;
    }
    break;
  }
  Matcher matcher=_incorrectLineBreakPattern3.matcher(newContent);
  while (matcher.find()) {
    String match=matcher.group();
    int closeParenthesesCount=StringUtil.count(match,StringPool.CLOSE_PARENTHESIS);
    int openParenthesesCount=StringUtil.count(match,StringPool.OPEN_PARENTHESIS);
    if (closeParenthesesCount == openParenthesesCount) {
      int lineCount=getLineCount(newContent,matcher.start());
      processErrorMessage(fileName,"line break: " + fileName + " "+ lineCount);
    }
  }
  newContent=formatAnnotations(fileName,StringPool.BLANK,newContent,StringPool.BLANK);
  matcher=_logPattern.matcher(newContent);
  if (matcher.find()) {
    String logClassName=matcher.group(1);
    if (!logClassName.equals(className)) {
      newContent=StringUtil.replaceLast(newContent,logClassName + ".class)",className + ".class)");
    }
  }
  if (!isExcludedPath(_staticLogVariableExcludes,absolutePath)) {
    newContent=StringUtil.replace(newContent,"private Log _log","private static final Log _log");
  }
  if (newContent.contains("*/\npackage ")) {
    processErrorMessage(fileName,"package: " + fileName);
  }
  if (portalSource && !_allowUseServiceUtilInServiceImpl && !className.equals("BaseServiceImpl")&& className.endsWith("ServiceImpl")&& newContent.contains("ServiceUtil.")) {
    processErrorMessage(fileName,"ServiceUtil: " + fileName);
  }
  if (portalSource && !isExcludedPath(_upgradeServiceUtilExcludes,absolutePath) && fileName.contains("/portal/upgrade/")&& !fileName.contains("/test/")&& !fileName.contains("/testIntegration/")&& newContent.contains("ServiceUtil.")) {
    processErrorMessage(fileName,"ServiceUtil: " + fileName);
  }
  boolean isRunOutsidePortalExclusion=isExcludedPath(getRunOutsidePortalExcludes(),absolutePath);
  if (!isRunOutsidePortalExclusion && !isExcludedPath(_proxyExcludes,absolutePath) && newContent.contains("import java.lang.reflect.Proxy;")) {
    processErrorMessage(fileName,"Proxy: " + fileName);
  }
  if (newContent.contains("import edu.emory.mathcs.backport.java")) {
    processErrorMessage(fileName,"edu.emory.mathcs.backport.java: " + fileName);
  }
  if (newContent.contains("import jodd.util.StringPool")) {
    processErrorMessage(fileName,"jodd.util.StringPool: " + fileName);
  }
  if (newContent.contains("com.liferay.portal.kernel.util.UnmodifiableList")) {
    processErrorMessage(fileName,"Use java.util.Collections.unmodifiableList instead of " + "com.liferay.portal.kernel.util.UnmodifiableList: " + fileName);
  }
  for (int pos1=-1; ; ) {
    pos1=newContent.indexOf(StringPool.TAB + "try {",pos1 + 1);
    if (pos1 == -1) {
      break;
    }
    int pos2=newContent.indexOf(StringPool.TAB + "try {",pos1 + 1);
    int pos3=newContent.indexOf("\"select count(",pos1);
    if ((pos2 != -1) && (pos3 != -1) && (pos2 < pos3)) {
      continue;
    }
    int pos4=newContent.indexOf("rs.getLong(1)",pos1);
    int pos5=newContent.indexOf(StringPool.TAB + "finally {",pos1);
    if ((pos3 == -1) || (pos4 == -1) || (pos5 == -1)) {
      break;
    }
    if ((pos3 < pos4) && (pos4 < pos5)) {
      processErrorMessage(fileName,"Use getInt(1) for count: " + fileName);
    }
  }
  matcher=_processCallablePattern.matcher(content);
  if (matcher.find() && !content.contains("private static final long serialVersionUID")) {
    processErrorMessage(fileName,"Assign ProcessCallable implementation a serialVersionUID: " + fileName);
  }
  checkLanguageKeys(fileName,absolutePath,newContent,languageKeyPattern);
  newContent=StringUtil.replace(newContent,StringPool.TAB + "for (;;) {",StringPool.TAB + "while (true) {");
  newContent=formatExceptions(newContent,file,packagePath,fileName);
  if (!isRunOutsidePortalExclusion && !isExcludedPath(_secureRandomExcludes,absolutePath) && content.contains("java.security.SecureRandom")&& !content.contains("javax.crypto.KeyGenerator")) {
    processErrorMessage(fileName,"Use SecureRandomUtil or com.liferay.portal.kernel.security." + "SecureRandom instead of java.security.SecureRandom: " + fileName);
  }
  checkLogLevel(newContent,fileName);
  checkSystemEventAnnotations(newContent,fileName);
  if (fileName.contains("/upgrade/") && newContent.contains("LocaleUtil.getDefault()")) {
    processErrorMessage(fileName,"Use UpgradeProcessUtil.getDefaultLanguageId(companyId) " + "instead of LocaleUtil.getDefault(): " + fileName);
  }
  newContent=StringUtil.replace(newContent," static interface "," interface ");
  newContent=fixSystemExceptions(newContent);
  if (portalSource && (fileName.contains("/test/integration/") || fileName.contains("/testIntegration/java"))) {
    newContent=StringUtil.replace(newContent,"FinderCacheUtil.clearCache();",StringPool.BLANK);
  }
  newContent=fixIncorrectParameterTypeForLanguageUtil(newContent,false,fileName);
  if (portalSource && fileName.contains("/portal-kernel/") && content.contains("import javax.servlet.jsp.")) {
    processErrorMessage(fileName,"Never import javax.servlet.jsp.* from portal-kernel " + fileName);
  }
  if (!isExcludedPath(_diamondOperatorExcludes,absolutePath)) {
    newContent=applyDiamondOperator(newContent);
  }
  checkFinderCacheInterfaceMethod(fileName,newContent);
  if (!fileName.contains("/test/") && !fileName.contains("/testIntegration/") && !isExcludedPath(_secureXmlExcludes,absolutePath)) {
    checkXMLSecurity(fileName,content,isRunOutsidePortalExclusion);
  }
  if (!fileName.contains("/test/") && !fileName.contains("/testIntegration/") && !isExcludedPath(_secureDeserializationExcludes,absolutePath)) {
    checkDeserializationSecurity(fileName,content,isRunOutsidePortalExclusion);
  }
  if (newContent.contains("org.testng.Assert")) {
    processErrorMessage(fileName,"Use org.junit.Assert instead of org.testng.Assert: " + fileName);
  }
  if (portalSource && isModulesFile(absolutePath)) {
    newContent=formatModulesFile(fileName,absolutePath,className,packagePath,newContent);
  }
  newContent=checkPrincipalException(newContent);
  if (fileName.endsWith("Upgrade.java") && newContent.contains("implements UpgradeStepRegistrator")) {
    matcher=_componentAnnotationPattern.matcher(newContent);
    if (matcher.find()) {
      String componentAnnotation=matcher.group();
      if (!componentAnnotation.contains("service =")) {
        processErrorMessage(fileName,"Missing service in @Component " + fileName);
      }
    }
  }
  if (newContent.contains(".supportsBatchUpdates()") && !fileName.endsWith("AutoBatchPreparedStatementUtil.java")) {
    processErrorMessage(fileName,"Use AutoBatchPreparedStatementUtil instead of " + "DatabaseMetaData.supportsBatchUpdates: " + fileName);
  }
  checkPropertyUtils(fileName,newContent);
  checkUpgradeClass(fileName,newContent);
  newContent=getCombinedLinesContent(newContent,_combinedLinesPattern1);
  newContent=getCombinedLinesContent(newContent,_combinedLinesPattern2);
  newContent=formatClassLine(newContent);
  newContent=fixIncorrectEmptyLineBeforeCloseCurlyBrace(newContent,fileName);
  pos=newContent.indexOf("\npublic ");
  if (pos != -1) {
    String javaClassContent=newContent.substring(pos + 1);
    int javaClassLineCount=getLineCount(newContent,pos + 1);
    newContent=formatJavaTerms(className,packagePath,file,fileName,absolutePath,newContent,javaClassContent,javaClassLineCount,_checkJavaFieldTypesExcludes,_javaTermAccessLevelModifierExcludes,_javaTermSortExcludes,_testAnnotationsExcludes);
  }
  newContent=formatJava(fileName,absolutePath,newContent);
  if (!isExcludedPath(_checkTabsExcludes,absolutePath)) {
    JavaSourceTabCalculator javaSourceTabCalculator=new JavaSourceTabCalculator();
    javaSourceTabCalculator.calculateTabs(fileName,newContent,(JavaSourceProcessor)this);
  }
  return StringUtil.replace(newContent,"\n\n\n","\n\n");
}
