{
  String moduleServicePackagePath=null;
  Matcher matcher=_serviceUtilImportPattern.matcher(content);
  while (matcher.find()) {
    String serviceUtilClassName=matcher.group(2);
    if (moduleServicePackagePath == null) {
      moduleServicePackagePath=getModuleServicePackagePath(fileName);
    }
    if (Validator.isNotNull(moduleServicePackagePath)) {
      String serviceUtilClassPackagePath=matcher.group(1);
      if (serviceUtilClassPackagePath.startsWith(moduleServicePackagePath)) {
        continue;
      }
    }
    processMessage(fileName,"LPS-59076: Use @Reference instead of calling " + serviceUtilClassName + " directly");
  }
  matcher=_referenceMethodPattern.matcher(content);
  while (matcher.find()) {
    String methodName=matcher.group(4);
    if (!methodName.startsWith("set")) {
      continue;
    }
    String annotationParameters=matcher.group(1);
    if (!annotationParameters.contains("unbind =")) {
      if (!content.contains("un" + methodName + "(")) {
        if (Validator.isNull(annotationParameters)) {
          return StringUtil.insert(content,"(unbind = \"-\")",matcher.start(1));
        }
        if (!annotationParameters.contains(StringPool.NEW_LINE)) {
          return StringUtil.insert(content,", unbind = \"-\"",matcher.end(1) - 1);
        }
        if (!annotationParameters.contains("\n\n")) {
          String indent="\t\t";
          int x=content.lastIndexOf("\n",matcher.end(1) - 1);
          return StringUtil.replaceFirst(content,"\n",",\n" + indent + "unbind = \"-\""+ "\n",x - 1);
        }
      }
    }
    String methodContent=matcher.group(6);
    Matcher referenceMethodContentMatcher=_referenceMethodContentPattern.matcher(methodContent);
    if (!referenceMethodContentMatcher.find()) {
      continue;
    }
    String typeName=matcher.group(5);
    String variableName=referenceMethodContentMatcher.group(1);
    StringBundler sb=new StringBundler(5);
    sb.append("private volatile ");
    sb.append(typeName);
    sb.append("\\s+");
    sb.append(variableName);
    sb.append(StringPool.SEMICOLON);
    Pattern privateVarPattern=Pattern.compile(sb.toString());
    Matcher privateVarMatcher=privateVarPattern.matcher(content);
    if (privateVarMatcher.find()) {
      String match=privateVarMatcher.group();
      String replacement=StringUtil.replace(match,"private volatile ","private ");
      return StringUtil.replace(content,match,replacement);
    }
  }
  return formatDuplicateReferenceMethods(fileName,content,className,packagePath);
}
