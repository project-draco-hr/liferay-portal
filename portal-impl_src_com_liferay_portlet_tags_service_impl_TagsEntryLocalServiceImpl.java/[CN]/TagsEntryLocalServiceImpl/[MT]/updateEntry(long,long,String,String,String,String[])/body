{
  name=name.trim().toLowerCase();
  if (Validator.isNull(vocabularyName)) {
    vocabularyName=PropsValues.TAGS_VOCABULARY_DEFAULT;
  }
  validate(name);
  TagsEntry entry=tagsEntryPersistence.findByPrimaryKey(entryId);
  if (!entry.getName().equals(name) && hasEntry(entry.getGroupId(),name)) {
    throw new DuplicateEntryException();
  }
  entry.setModifiedDate(new Date());
  if (Validator.isNotNull(parentEntryName)) {
    TagsEntry parentEntry=getEntry(entry.getGroupId(),parentEntryName);
    entry.setParentEntryId(parentEntry.getEntryId());
  }
 else {
    entry.setParentEntryId(TagsEntryConstants.DEFAULT_PARENT_ENTRY_ID);
  }
  entry.setName(name);
  TagsVocabulary vocabulary=null;
  try {
    vocabulary=tagsVocabularyPersistence.findByG_N(entry.getGroupId(),vocabularyName);
  }
 catch (  NoSuchVocabularyException nsve) {
    if (vocabularyName.equals(PropsValues.TAGS_VOCABULARY_DEFAULT)) {
      vocabulary=tagsVocabularyLocalService.addVocabularyToGroup(entry.getUserId(),entry.getGroupId(),vocabularyName,true,Boolean.TRUE,Boolean.TRUE,null,null);
    }
 else {
      throw nsve;
    }
  }
  entry.setVocabularyId(vocabulary.getVocabularyId());
  tagsEntryPersistence.update(entry,false);
  Set<Long> newProperties=new HashSet<Long>();
  List<TagsProperty> oldProperties=tagsPropertyPersistence.findByEntryId(entryId);
  for (int i=0; i < properties.length; i++) {
    String[] property=StringUtil.split(properties[i],StringPool.COLON);
    long propertyId=0;
    if (property.length > 0) {
      propertyId=GetterUtil.getLong(property[0]);
    }
    String key=StringPool.BLANK;
    if (property.length > 1) {
      key=GetterUtil.getString(property[1]);
    }
    String value=StringPool.BLANK;
    if (property.length > 2) {
      value=GetterUtil.getString(property[2]);
    }
    if (propertyId == 0) {
      if (Validator.isNotNull(key)) {
        tagsPropertyLocalService.addProperty(userId,entryId,key,value);
      }
    }
 else {
      if (Validator.isNull(key)) {
        tagsPropertyLocalService.deleteProperty(propertyId);
      }
 else {
        tagsPropertyLocalService.updateProperty(propertyId,key,value);
        newProperties.add(propertyId);
      }
    }
  }
  for (  TagsProperty property : oldProperties) {
    if (!newProperties.contains(property.getPropertyId())) {
      tagsPropertyLocalService.deleteProperty(property);
    }
  }
  return entry;
}
