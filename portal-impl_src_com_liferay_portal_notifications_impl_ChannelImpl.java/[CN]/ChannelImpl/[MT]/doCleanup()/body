{
  Lock lock=_channelRWLock.writeLock();
  try {
    lock.lock();
    Iterator<NotificationEvent> eventsIter=_notificationEvents.iterator();
    long currentTime=System.currentTimeMillis();
    while (eventsIter.hasNext()) {
      NotificationEvent notificationEvent=eventsIter.next();
      boolean remove=evaluateRemoval(notificationEvent,currentTime);
      if (remove) {
        eventsIter.remove();
      }
    }
    Collection<String> invalidEventUuids=new ArrayList<String>(_unconfirmedNotificationEvents.size());
    Iterator<Map.Entry<String,NotificationEvent>> notificationEvents=_unconfirmedNotificationEvents.entrySet().iterator();
    while (notificationEvents.hasNext()) {
      Map.Entry<String,NotificationEvent> event=notificationEvents.next();
      boolean remove=evaluateRemoval(event.getValue(),currentTime);
      if (remove) {
        invalidEventUuids.add(event.getKey());
        notificationEvents.remove();
      }
    }
    _userNotificationEventLocalService.deleteUserNotificationEvents(invalidEventUuids);
  }
 catch (  Exception e) {
    throw new ChannelException("Unable to complete cleanup of channel" + getUserId(),e);
  }
 finally {
    lock.unlock();
  }
}
