{
  final Project project=buildChangeLogTask.getProject();
  Task task=project.task(PRINT_ARTIFACT_PUBLISH_COMMANDS);
  task.doLast(new Action<Task>(){
    @Override public void execute(    Task task){
      List<String> commands=new ArrayList<>();
      boolean gradleDaemon=_getGradleDaemon(task);
      String gradleRelativePath=_relativize(_getGradlewFile());
      commands.add("cd " + FileUtil.getAbsolutePath(project.getRootDir()));
      if (!hasBaseline(project)) {
        commands.addAll(_getPublishCommands(gradleRelativePath,gradleDaemon,true));
      }
      commands.add(_getGradleCommand(gradleRelativePath,buildChangeLogTask,gradleDaemon));
      commands.add("git add " + _relativize(buildChangeLogTask.getChangeLogFile()));
      commands.add(_getGitCommitCommand("change log",false,true,true));
      commands.add(_getGradleCommand(gradleRelativePath,BASELINE_TASK_NAME,gradleDaemon));
      commands.add("git add --all " + _relativize(project.getProjectDir()));
      commands.add(_getGitCommitCommand("packageinfo",false,false,true));
      commands.addAll(_getPublishCommands(gradleRelativePath,gradleDaemon,false));
      System.out.println();
      for (      String command : commands) {
        System.out.print(" && ");
        System.out.print(command);
      }
      if (GradleUtil.getProperty(project,"first",false)) {
        throw new GradleException();
      }
    }
    private String _getGitCommitCommand(    String message,    boolean all,    boolean ignored,    boolean quiet){
      StringBuilder sb=new StringBuilder();
      if (all || quiet) {
        sb.append("(git diff-index --quiet HEAD || ");
      }
      sb.append("git commit ");
      if (all) {
        sb.append("--all ");
      }
      sb.append("--message=\"");
      if (ignored) {
        sb.append(_IGNORED_MESSAGE_PATTERN);
        sb.append(' ');
      }
      sb.append(project.getName());
      sb.append(' ');
      sb.append(project.getVersion());
      sb.append(' ');
      sb.append(message);
      sb.append('"');
      if (all || quiet) {
        sb.append(')');
      }
      return sb.toString();
    }
    private String _getGradleCommand(    String gradleRelativePath,    String taskName,    boolean gradleDaemon,    String... arguments){
      Task task=GradleUtil.getTask(project,taskName);
      return _getGradleCommand(gradleRelativePath,task,gradleDaemon,arguments);
    }
    private String _getGradleCommand(    String gradleRelativePath,    Task task,    boolean gradleDaemon,    String... arguments){
      StringBuilder sb=new StringBuilder();
      sb.append(gradleRelativePath);
      sb.append(' ');
      sb.append(task.getPath());
      if (gradleDaemon) {
        sb.append(" --daemon");
      }
      for (      String argument : arguments) {
        sb.append(' ');
        sb.append(argument);
      }
      return sb.toString();
    }
    private boolean _getGradleDaemon(    Task task){
      boolean gradleDaemon=true;
      String gradleDaemonString=GradleUtil.getTaskPrefixedProperty(task,"daemon");
      if (Validator.isNotNull(gradleDaemonString)) {
        gradleDaemon=Boolean.parseBoolean(gradleDaemonString);
      }
      return gradleDaemon;
    }
    private File _getGradlewFile(){
      File rootDir=portalRootDir;
      if (portalRootDir == null) {
        rootDir=project.getRootDir();
      }
      return new File(rootDir,"gradlew");
    }
    private List<String> _getPublishCommands(    String gradleRelativePath,    boolean gradleDaemon,    boolean excludeUpdateFileVersions){
      List<String> commands=new ArrayList<>();
      commands.add(_getGradleCommand(gradleRelativePath,BasePlugin.UPLOAD_ARCHIVES_TASK_NAME,gradleDaemon,"-P" + _SNAPSHOT_PROPERTY_NAME));
      String[] arguments;
      if (excludeUpdateFileVersions) {
        arguments=new String[]{"-x",UPDATE_FILE_VERSIONS_TASK_NAME};
      }
 else {
        arguments=new String[0];
      }
      commands.add(_getGradleCommand(gradleRelativePath,BasePlugin.UPLOAD_ARCHIVES_TASK_NAME,gradleDaemon,arguments));
      commands.add("git add " + _relativize("bnd.bnd"));
      File moduleConfigFile=getModuleConfigFile(project);
      if ((moduleConfigFile != null) && moduleConfigFile.exists()) {
        commands.add("git add " + _relativize(moduleConfigFile));
      }
      commands.add(_getGitCommitCommand("prep next",false,true,false));
      commands.add("git add " + _relativize(recordArtifactTask.getOutputFile()));
      commands.add(_getGitCommitCommand("artifact properties",false,true,false));
      commands.add(_getGitCommitCommand("apply",true,false,true));
      return commands;
    }
    private String _relativize(    File file){
      Project rootProject=project.getRootProject();
      return rootProject.relativePath(file);
    }
    private String _relativize(    String fileName){
      File file=project.file(fileName);
      return _relativize(file);
    }
  }
);
  if (gitRepoDir != null) {
    task.onlyIf(new LeafArtifactSpec(gitRepoDir));
  }
  task.setDescription("Prints the artifact publish commands if this project has been " + "changed since the last publish.");
  configureTaskEnabledIfStale(task,recordArtifactTask,testProject);
  return task;
}
