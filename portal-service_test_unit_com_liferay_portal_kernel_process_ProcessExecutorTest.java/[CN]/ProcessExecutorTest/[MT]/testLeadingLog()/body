{
  boolean isCodeCoverageOn=Boolean.getBoolean("junit.code.coverage");
  String leadingLog="Test leading log.\n";
  String bodyLog="Test body log.\n";
  Logger logger=_getLogger();
  Level level=logger.getLevel();
  logger.setLevel(Level.WARNING);
  CaptureHandler captureHandler=new CaptureHandler();
  logger.addHandler(captureHandler);
  try {
    LeadingLogProcessCallable leadingLogProcessCallable=new LeadingLogProcessCallable(leadingLog,bodyLog);
    List<String> arguments=_createArguments();
    Future<String> future=ProcessExecutor.execute(_classPath,arguments,leadingLogProcessCallable);
    future.get();
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    if (isCodeCoverageOn) {
      assertEquals(2,logRecords.size());
    }
 else {
      assertEquals(1,logRecords.size());
    }
    LogRecord logRecord=logRecords.get(0);
    assertEquals("Found corrupt leading log " + leadingLog,logRecord.getMessage());
    if (isCodeCoverageOn) {
      logRecord=logRecords.get(1);
      String message=logRecord.getMessage();
      _assertBrokenPiping(message);
    }
  }
  finally {
    logger.removeHandler(captureHandler);
    logger.setLevel(level);
  }
  logger.setLevel(Level.FINE);
  captureHandler=new CaptureHandler();
  logger.addHandler(captureHandler);
  try {
    LeadingLogProcessCallable leadingLogProcessCallable=new LeadingLogProcessCallable(leadingLog,bodyLog);
    List<String> arguments=_createArguments();
    Future<String> future=ProcessExecutor.execute(_classPath,arguments,leadingLogProcessCallable);
    future.get();
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    if (isCodeCoverageOn) {
      assertEquals(3,logRecords.size());
    }
 else {
      assertEquals(2,logRecords.size());
    }
    LogRecord logRecord1=logRecords.get(0);
    assertEquals("Found corrupt leading log " + leadingLog,logRecord1.getMessage());
    LogRecord logRecord2=logRecords.get(1);
    String message=logRecord2.getMessage();
    assertTrue(message.contains("Invoked generic process callable "));
    if (isCodeCoverageOn) {
      LogRecord logRecord3=logRecords.get(2);
      message=logRecord3.getMessage();
      _assertBrokenPiping(message);
    }
  }
  finally {
    logger.removeHandler(captureHandler);
    logger.setLevel(level);
  }
  logger.setLevel(Level.SEVERE);
  captureHandler=new CaptureHandler();
  logger.addHandler(captureHandler);
  try {
    LeadingLogProcessCallable leadingLogProcessCallable=new LeadingLogProcessCallable(leadingLog,bodyLog);
    List<String> arguments=_createArguments();
    Future<String> future=ProcessExecutor.execute(_classPath,arguments,leadingLogProcessCallable);
    future.get();
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    if (isCodeCoverageOn) {
      assertEquals(1,logRecords.size());
      LogRecord logRecord=logRecords.get(0);
      _assertBrokenPiping(logRecord.getMessage());
    }
 else {
      assertEquals(0,logRecords.size());
    }
  }
  finally {
    logger.removeHandler(captureHandler);
    logger.setLevel(level);
  }
}
