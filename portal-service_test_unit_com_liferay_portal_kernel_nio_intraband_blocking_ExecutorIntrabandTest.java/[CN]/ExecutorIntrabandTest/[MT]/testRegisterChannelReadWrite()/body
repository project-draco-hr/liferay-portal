{
  try {
    _executorIntraband.registerChannel(null,null);
    Assert.fail();
  }
 catch (  NullPointerException npe) {
    Assert.assertEquals("Gathering byte channel is null",npe.getMessage());
  }
  try {
    _executorIntraband.registerChannel(null,IntrabandTestUtil.<GatheringByteChannel>createProxy(GatheringByteChannel.class));
    Assert.fail();
  }
 catch (  NullPointerException npe) {
    Assert.assertEquals("Scattering byte channel is null",npe.getMessage());
  }
  Pipe pipe=Pipe.open();
  SourceChannel sourceChannel=pipe.source();
  SinkChannel sinkChannel=pipe.sink();
  sourceChannel.configureBlocking(false);
  try {
    _executorIntraband.registerChannel(sourceChannel,sinkChannel);
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Scattering byte channel is of type SelectableChannel and " + "configured in nonblocking mode",iae.getMessage());
  }
  sourceChannel.configureBlocking(true);
  sinkChannel.configureBlocking(false);
  try {
    _executorIntraband.registerChannel(sourceChannel,sinkChannel);
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Gathering byte channel is of type SelectableChannel and " + "configured in nonblocking mode",iae.getMessage());
  }
  sourceChannel.configureBlocking(true);
  sinkChannel.configureBlocking(true);
  try {
    FutureRegistrationReference futureRegistrationReference=(FutureRegistrationReference)_executorIntraband.registerChannel(sourceChannel,sinkChannel);
    Assert.assertSame(_executorIntraband,futureRegistrationReference.getIntraband());
    Assert.assertTrue(futureRegistrationReference.isValid());
    futureRegistrationReference.writeFuture.cancel(true);
    Assert.assertFalse(futureRegistrationReference.isValid());
    futureRegistrationReference.cancelRegistration();
    Assert.assertFalse(futureRegistrationReference.isValid());
    ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)_executorIntraband.executorService;
    while (threadPoolExecutor.getActiveCount() != 0)     ;
  }
  finally {
    sourceChannel.close();
    sinkChannel.close();
  }
  File tempFile=new File("tempFile");
  tempFile.deleteOnExit();
  try (RandomAccessFile randomAccessFile=new RandomAccessFile(tempFile,"rw")){
    randomAccessFile.setLength(Integer.MAX_VALUE);
  }
   FileInputStream fileInputStream=new FileInputStream(tempFile);
  FileOutputStream fileOutputStream=new FileOutputStream(tempFile,true);
  FileChannel readFileChannel=fileInputStream.getChannel();
  FileChannel writeFileChannel=fileOutputStream.getChannel();
  try {
    FutureRegistrationReference futureRegistrationReference=(FutureRegistrationReference)_executorIntraband.registerChannel(readFileChannel,writeFileChannel);
    Assert.assertSame(_executorIntraband,futureRegistrationReference.getIntraband());
    Assert.assertTrue(futureRegistrationReference.isValid());
    futureRegistrationReference.writeFuture.cancel(true);
    Assert.assertFalse(futureRegistrationReference.isValid());
    futureRegistrationReference.cancelRegistration();
    Assert.assertFalse(futureRegistrationReference.isValid());
    ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)_executorIntraband.executorService;
    while (threadPoolExecutor.getActiveCount() != 0)     ;
  }
  finally {
    readFileChannel.close();
    writeFileChannel.close();
  }
}
