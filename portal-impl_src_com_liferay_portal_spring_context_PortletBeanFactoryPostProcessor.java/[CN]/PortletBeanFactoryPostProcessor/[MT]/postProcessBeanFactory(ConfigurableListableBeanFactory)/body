{
  ChainableMethodAdviceInjectorCollector.collect(configurableListableBeanFactory);
  ClassLoader classLoader=getClassLoader();
  configurableListableBeanFactory.setBeanClassLoader(classLoader);
  ListableBeanFactory parentListableBeanFactory=(ListableBeanFactory)configurableListableBeanFactory.getParentBeanFactory();
  if (parentListableBeanFactory != null) {
    Map<String,BeanPostProcessor> beanPostProcessors=parentListableBeanFactory.getBeansOfType(BeanPostProcessor.class,true,false);
    for (    BeanPostProcessor beanPostProcessor : beanPostProcessors.values()) {
      if (beanPostProcessor instanceof BeanFactoryAware) {
        BeanFactoryAware beanFactoryAware=(BeanFactoryAware)beanPostProcessor;
        beanFactoryAware.setBeanFactory(configurableListableBeanFactory);
      }
      if (beanPostProcessor instanceof AbstractAutoProxyCreator) {
        AbstractAutoProxyCreator abstractAutoProxyCreator=(AbstractAutoProxyCreator)beanPostProcessor;
        abstractAutoProxyCreator.setProxyClassLoader(classLoader);
      }
      configurableListableBeanFactory.addBeanPostProcessor(beanPostProcessor);
    }
  }
  String[] names=configurableListableBeanFactory.getBeanDefinitionNames();
  for (  String name : names) {
    if (!name.contains(SpringFactoryUtil.class.getName())) {
      continue;
    }
    try {
      Object bean=configurableListableBeanFactory.getBean(name);
      if (bean instanceof BeanPostProcessor) {
        configurableListableBeanFactory.addBeanPostProcessor((BeanPostProcessor)bean);
      }
    }
 catch (    BeanIsAbstractException biae) {
      continue;
    }
  }
}
