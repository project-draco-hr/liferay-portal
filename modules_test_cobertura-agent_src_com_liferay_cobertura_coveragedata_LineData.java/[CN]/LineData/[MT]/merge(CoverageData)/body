{
  LineData lineData=(LineData)coverageData;
  getBothLocks(lineData);
  try {
    this.hits+=lineData.hits;
    ConcurrentMap<Integer,JumpData> otherJumpDatas=lineData._jumpDatas;
    for (    JumpData jumpData : otherJumpDatas.values()) {
      JumpData previousJumpData=_jumpDatas.putIfAbsent(jumpData.getConditionNumber(),jumpData);
      if (previousJumpData != null) {
        previousJumpData.merge(jumpData);
      }
    }
    if (lineData.switches != null)     if (this.switches == null)     this.switches=lineData.switches;
 else {
      for (int i=Math.min(this.switches.size(),lineData.switches.size()) - 1; i >= 0; i--)       ((SwitchData)this.switches.get(i)).merge((SwitchData)lineData.switches.get(i));
      for (int i=Math.min(this.switches.size(),lineData.switches.size()); i < lineData.switches.size(); i++)       this.switches.add(lineData.switches.get(i));
    }
  }
  finally {
    lock.unlock();
    lineData.lock.unlock();
  }
}
