{
  Bundle bundle=serviceReference.getBundle();
  BundleContext bundleContext=bundle.getBundleContext();
  SchedulerEventMessageListener schedulerEventMessageListener=bundleContext.getService(serviceReference);
  SchedulerEntry schedulerEntry=schedulerEventMessageListener.getSchedulerEntry();
  StorageType storageType=StorageType.MEMORY_CLUSTERED;
  if (schedulerEntry == null) {
    return null;
  }
  if (schedulerEntry instanceof StorageTypeAware) {
    StorageTypeAware storageTypeAware=(StorageTypeAware)schedulerEntry;
    storageType=storageTypeAware.getStorageType();
  }
  String destinationName=(String)serviceReference.getProperty("destination.name");
  if (Validator.isNull(destinationName)) {
    destinationName=DestinationNames.SCHEDULER_DISPATCH;
  }
  SchedulerClusterInvokingThreadLocal.setEnabled(false);
  try {
    schedule(schedulerEntry.getTrigger(),storageType,schedulerEntry.getDescription(),destinationName,null,0);
    Dictionary<String,Object> properties=new HashMapDictionary<>();
    properties.put("destination.name",destinationName);
    ServiceRegistration<MessageListener> serviceRegistration=bundleContext.registerService(MessageListener.class,schedulerEventMessageListener,properties);
    _messageListenerServiceRegistrations.put(schedulerEntry.getEventListenerClass(),serviceRegistration);
    return schedulerEventMessageListener;
  }
 catch (  SchedulerException se) {
    _log.error(se,se);
  }
 finally {
    SchedulerClusterInvokingThreadLocal.setEnabled(true);
  }
  return null;
}
