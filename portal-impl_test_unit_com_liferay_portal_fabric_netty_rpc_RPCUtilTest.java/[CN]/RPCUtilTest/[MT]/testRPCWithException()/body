{
  ProcessException testException=new ProcessException("message");
  Future<Serializable> future=RPCUtil.execute(_embeddedChannel,new ExceptionRPCCallable(testException));
  _embeddedChannel.writeInbound(_embeddedChannel.readOutbound());
  _embeddedChannel.writeInbound(_embeddedChannel.readOutbound());
  try {
    future.get();
    Assert.fail();
  }
 catch (  ExecutionException ee) {
    Throwable throwable=ee.getCause();
    Assert.assertSame(testException,throwable);
  }
  _embeddedChannel.close();
  Future<String> channelFailureFuture=RPCUtil.execute(_embeddedChannel,new ResultRPCCallable(StringPool.BLANK));
  try {
    channelFailureFuture.get();
    Assert.fail();
  }
 catch (  ExecutionException ee) {
    Throwable throwable=ee.getCause();
    Assert.assertSame(ClosedChannelException.class,throwable.getClass());
  }
  Attribute<AsyncBroker<Long,String>> attribute=_embeddedChannel.attr(ReflectionTestUtil.<AttributeKey<AsyncBroker<Long,String>>>getFieldValue(NettyChannelAttributes.class,"_asyncBrokerKey"));
  final AtomicLong keyRef=new AtomicLong();
  attribute.set(new AsyncBroker<Long,String>(){
    @Override public NoticeableFuture<String> post(    Long key){
      keyRef.set(key);
      return new DefaultNoticeableFuture<String>();
    }
  }
);
  try (CaptureHandler captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCUtil.class.getName(),Level.SEVERE)){
    RPCUtil.execute(_embeddedChannel,new ResultRPCCallable(StringPool.BLANK));
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    Assert.assertEquals(1,logRecords.size());
    LogRecord logRecord=logRecords.get(0);
    Assert.assertEquals("Unable to place exception because no future exists with ID " + keyRef.get(),logRecord.getMessage());
    Throwable throwable=logRecord.getThrown();
    Assert.assertSame(ClosedChannelException.class,throwable.getClass());
  }
 }
