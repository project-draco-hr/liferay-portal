{
  System.setProperty(FinalizeManager.class.getName() + ".thread.enabled",StringPool.FALSE);
  String testKey1="testKey1";
  String testKey2=new String(testKey1);
  Object testValue1=new Object();
  Object testValue2=new Object();
  ConcurrentMap<String,Object> concurrentMap=new ConcurrentIdentityHashMap<String,Object>(new ConcurrentReferenceValueHashMap<IdentityKey<String>,Object>(FinalizeManager.WEAK_REFERENCE_FACTORY));
  Assert.assertNull(concurrentMap.put(testKey1,testValue1));
  Assert.assertNull(concurrentMap.put(testKey2,testValue2));
  Assert.assertEquals(2,concurrentMap.size());
  Assert.assertTrue(concurrentMap.containsKey(testKey1));
  Assert.assertTrue(concurrentMap.containsValue(testValue1));
  Assert.assertTrue(concurrentMap.containsKey(testKey2));
  Assert.assertTrue(concurrentMap.containsValue(testValue2));
  Assert.assertSame(testValue1,concurrentMap.get(testKey1));
  Assert.assertSame(testValue2,concurrentMap.get(testKey2));
  testValue1=null;
  GCUtil.gc(true);
  ReflectionTestUtil.invoke(FinalizeManager.class,"_pollingCleanup",new Class<?>[0]);
  Assert.assertEquals(1,concurrentMap.size());
  Assert.assertTrue(concurrentMap.containsKey(testKey2));
  testValue2=null;
  GCUtil.gc(true);
  ReflectionTestUtil.invoke(FinalizeManager.class,"_pollingCleanup",new Class<?>[0]);
  Assert.assertTrue(concurrentMap.isEmpty());
}
