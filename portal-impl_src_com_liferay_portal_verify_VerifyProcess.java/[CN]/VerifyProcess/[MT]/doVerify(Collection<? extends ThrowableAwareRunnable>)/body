{
  List<Throwable> throwables=new ArrayList<Throwable>();
  if (throwableAwareRunnables.size() < PropsValues.VERIFY_PROCESS_CONCURRENCY_THRESHOLD) {
    for (    ThrowableAwareRunnable throwableAwareRunnable : throwableAwareRunnables) {
      throwableAwareRunnable.run();
      if (throwableAwareRunnable.hasException()) {
        throwables.add(throwableAwareRunnable.getThrowable());
      }
    }
  }
 else {
    ExecutorService executorService=Executors.newFixedThreadPool(throwableAwareRunnables.size());
    List<Callable<Object>> jobs=new ArrayList<Callable<Object>>(throwableAwareRunnables.size());
    for (    Runnable runnable : throwableAwareRunnables) {
      jobs.add(Executors.callable(runnable));
    }
    try {
      List<Future<Object>> futures=executorService.invokeAll(jobs);
      for (      Future<Object> future : futures) {
        try {
          future.get();
        }
 catch (        ExecutionException ee) {
          throwables.add(ee.getCause());
        }
      }
    }
  finally {
      executorService.shutdown();
    }
  }
  if (!throwables.isEmpty()) {
    throw new BulkException("Verification error: " + getClass().getName(),throwables);
  }
}
