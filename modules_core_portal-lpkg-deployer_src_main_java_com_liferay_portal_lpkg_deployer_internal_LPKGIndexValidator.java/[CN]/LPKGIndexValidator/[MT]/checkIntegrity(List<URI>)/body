{
  if (Files.notExists(_integrityPropertiesFilePath)) {
    if (_log.isInfoEnabled()) {
      _log.info("Skip integrity check because " + _integrityPropertiesFilePath + " does not exist");
    }
    return false;
  }
  Properties properties=new Properties();
  try (InputStream inputStream=Files.newInputStream(_integrityPropertiesFilePath)){
    properties.load(inputStream);
  }
 catch (  IOException ioe) {
    _log.error("Unable to read " + _integrityPropertiesFilePath,ioe);
    return false;
  }
  Set<String> keys=new HashSet<>();
  for (  URI uri : indexURIs) {
    keys.add(_toKey(uri));
  }
  if (!keys.equals(properties.stringPropertyNames())) {
    if (_log.isInfoEnabled()) {
      List<String> expectedKeys=new ArrayList<>(properties.stringPropertyNames());
      Collections.sort(expectedKeys);
      List<String> actualKeys=new ArrayList<>(keys);
      Collections.sort(actualKeys);
      _log.info("Failed integrity check because expected keys: " + expectedKeys + " do not match actual keys: "+ actualKeys);
    }
    return false;
  }
  for (  URI uri : indexURIs) {
    String key=_toKey(uri);
    try {
      String expectedChecksum=properties.getProperty(key);
      String actualChecksum=_toChecksum(uri);
      if (!Objects.equals(expectedChecksum,actualChecksum)) {
        if (_log.isInfoEnabled()) {
          _log.info("Failed integrity check because of mismatched " + "checksum for " + key);
        }
        return false;
      }
    }
 catch (    Exception e) {
      _log.error("Unable to generate checksum for " + uri);
      return false;
    }
  }
  if (_log.isInfoEnabled()) {
    _log.info("Passed integrity check");
  }
  return true;
}
