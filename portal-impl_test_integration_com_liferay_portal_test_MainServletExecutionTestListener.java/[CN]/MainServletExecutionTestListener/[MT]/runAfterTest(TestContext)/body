{
  Map<Class<?>,FieldsBag> deleteAfterTestRunFieldBags=new HashMap<Class<?>,FieldsBag>();
  Class<?> testClass=testContext.getClazz();
  Object instance=testContext.getInstance();
  while (testClass != null) {
    for (    Field field : testClass.getDeclaredFields()) {
      DeleteAfterTestRun deleteAfterTestRun=field.getAnnotation(DeleteAfterTestRun.class);
      if (deleteAfterTestRun == null) {
        continue;
      }
      Class<?> fieldClass=field.getType();
      if (PersistedModel.class.isAssignableFrom(fieldClass)) {
        addField(deleteAfterTestRunFieldBags,fieldClass,field);
        continue;
      }
      if (fieldClass.isArray()) {
        if (!PersistedModel.class.isAssignableFrom(fieldClass.getComponentType())) {
          throw new IllegalArgumentException("Unable to annotate field " + field + " because it is not an array of type "+ PersistedModel.class);
        }
        addField(deleteAfterTestRunFieldBags,fieldClass.getComponentType(),field);
        continue;
      }
      if (Collection.class.isAssignableFrom(fieldClass)) {
        try {
          field.setAccessible(true);
          Collection<?> collection=(Collection<?>)field.get(instance);
          if ((collection == null) || collection.isEmpty()) {
            continue;
          }
          Class<?> collectionType=detectedCollectionType(collection);
          if (collectionType == null) {
            throw new IllegalArgumentException("Unable to annotate field " + field + " because it is not a Collection "+ "of type "+ PersistedModel.class);
          }
          addField(deleteAfterTestRunFieldBags,collectionType,field);
        }
 catch (        Exception e) {
          _log.error("Unable to detect Collection element type",e);
        }
        continue;
      }
      throw new IllegalArgumentException("Unable to annotate field " + field + " because it is not type of "+ PersistedModel.class+ ", either an array or collect of it");
    }
    testClass=testClass.getSuperclass();
  }
  Set<Map.Entry<Class<?>,FieldsBag>> set=deleteAfterTestRunFieldBags.entrySet();
  Iterator<Map.Entry<Class<?>,FieldsBag>> iterator=set.iterator();
  while (iterator.hasNext()) {
    Map.Entry<Class<?>,FieldsBag> entry=iterator.next();
    Class<?> clazz=entry.getKey();
    if (_orderedClasses.contains(clazz)) {
      continue;
    }
    iterator.remove();
    removeField(entry.getValue(),instance);
  }
  for (  Class<?> clazz : _orderedClasses) {
    FieldsBag fieldsBag=deleteAfterTestRunFieldBags.remove(clazz);
    if (fieldsBag == null) {
      continue;
    }
    removeField(fieldsBag,instance);
  }
}
