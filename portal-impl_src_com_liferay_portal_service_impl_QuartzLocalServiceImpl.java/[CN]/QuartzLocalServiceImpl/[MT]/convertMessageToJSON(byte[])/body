{
  ObjectInputStream objectInputStream=new BackwardCompatibleObjectInputStream(new UnsyncByteArrayInputStream(jobData));
  Map<Object,Object> jobDataMap=(Map<Object,Object>)objectInputStream.readObject();
  objectInputStream.close();
  Map<Object,Object> tempJobDataMap=new HashMap<Object,Object>(jobDataMap);
  jobDataMap.clear();
  boolean modifiedKeys=false;
  for (  Map.Entry<Object,Object> entry : tempJobDataMap.entrySet()) {
    Object key=entry.getKey();
    if (key instanceof String) {
      String stringKey=(String)key;
      if (stringKey.startsWith("destination")) {
        key=SchedulerEngine.DESTINATION_NAME;
      }
 else       if (stringKey.equals("messageBody")) {
        key=SchedulerEngine.MESSAGE;
        jobDataMap.put(key,convertOldJsonStringToObject(entry.getValue()));
        continue;
      }
 else {
        key=stringKey.toUpperCase();
      }
      modifiedKeys=true;
    }
    jobDataMap.put(key,entry.getValue());
  }
  Object object=jobDataMap.get(SchedulerEngine.MESSAGE);
  if ((object == null) || (object instanceof String) || !modifiedKeys) {
    return null;
  }
  Message message=null;
  if (object instanceof Message) {
    message=(Message)object;
  }
 else {
    message=new Message();
    message.setPayload(object);
  }
  String messageJSON=JSONFactoryUtil.serialize(message);
  jobDataMap.put(SchedulerEngine.MESSAGE,messageJSON);
  UnsyncByteArrayOutputStream newJobDataOutputStream=new UnsyncByteArrayOutputStream();
  ObjectOutputStream objectOutputStream=new ObjectOutputStream(newJobDataOutputStream);
  objectOutputStream.writeObject(jobDataMap);
  objectOutputStream.close();
  return newJobDataOutputStream.toByteArray();
}
