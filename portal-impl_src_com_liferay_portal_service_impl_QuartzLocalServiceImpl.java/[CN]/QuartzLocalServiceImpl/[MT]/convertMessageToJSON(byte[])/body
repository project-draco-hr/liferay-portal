{
  ObjectInputStream objectInputStream=new BackwardCompatibleObjectInputStream(new UnsyncByteArrayInputStream(jobData));
  Map<Object,Object> jobDataMap=(Map<Object,Object>)objectInputStream.readObject();
  objectInputStream.close();
  Map<Object,Object> tempJobDataMap=new HashMap<Object,Object>(jobDataMap);
  jobDataMap.clear();
  boolean modifiedKeys=false;
  for (  Map.Entry<Object,Object> entry : tempJobDataMap.entrySet()) {
    Object key=entry.getKey();
    if (key instanceof String) {
      key=((String)key).toUpperCase();
      modifiedKeys=true;
    }
    jobDataMap.put(key,entry.getValue());
  }
  Object object=jobDataMap.get(SchedulerEngine.MESSAGE);
  if ((object == null) || (object instanceof String) || !modifiedKeys) {
    return null;
  }
  Message message=null;
  if (object instanceof Message) {
    message=(Message)object;
  }
 else {
    message=new Message();
    message.setPayload(object);
  }
  String messageJSON=JSONFactoryUtil.serialize(message);
  jobDataMap.put(SchedulerEngine.MESSAGE,messageJSON);
  UnsyncByteArrayOutputStream newJobDataOutputStream=new UnsyncByteArrayOutputStream();
  ObjectOutputStream objectOutputStream=new ObjectOutputStream(newJobDataOutputStream);
  objectOutputStream.writeObject(jobDataMap);
  objectOutputStream.close();
  return newJobDataOutputStream.toByteArray();
}
