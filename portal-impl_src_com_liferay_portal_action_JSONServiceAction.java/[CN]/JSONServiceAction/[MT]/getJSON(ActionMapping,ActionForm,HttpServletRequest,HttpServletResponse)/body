{
  String className=ParamUtil.getString(request,"serviceClassName");
  String methodName=ParamUtil.getString(request,"serviceMethodName");
  String[] serviceParameters=StringUtil.split(ParamUtil.getString(request,"serviceParameters"));
  String[] serviceParameterTypes=StringUtil.split(ParamUtil.getString(request,"serviceParameterTypes"));
  if (!isValidRequest(request)) {
    return null;
  }
  Class<?> classObj=Class.forName(className);
  Object[] methodAndParameterTypes=getMethodAndParameterTypes(classObj,methodName,serviceParameters,serviceParameterTypes);
  if (methodAndParameterTypes != null) {
    Method method=(Method)methodAndParameterTypes[0];
    Class<?>[] parameterTypes=(Class[])methodAndParameterTypes[1];
    Object[] args=new Object[serviceParameters.length];
    for (int i=0; i < serviceParameters.length; i++) {
      args[i]=getArgValue(request,classObj,methodName,serviceParameters[i],parameterTypes[i]);
    }
    try {
      if (_log.isDebugEnabled()) {
        _log.debug("Invoking class " + classObj + " on method "+ method.getName()+ " with args "+ args);
      }
      Object returnObj=method.invoke(classObj,args);
      if (returnObj != null) {
        if (returnObj instanceof BaseModel) {
          String serlializerClassName=getSerializerClassName(returnObj);
          MethodWrapper methodWrapper=new MethodWrapper(serlializerClassName,"toJSONObject",returnObj);
          JSONObject jsonObj=(JSONObject)MethodInvoker.invoke(methodWrapper,false);
          return jsonObj.toString();
        }
 else         if (returnObj instanceof List) {
          JSONArray jsonArray=JSONFactoryUtil.createJSONArray();
          List<Object> returnList=(List<Object>)returnObj;
          if (!returnList.isEmpty()) {
            Object returnItem0=returnList.get(0);
            String serlializerClassName=getSerializerClassName(returnItem0);
            MethodWrapper methodWrapper=new MethodWrapper(serlializerClassName,"toJSONArray",returnObj);
            jsonArray=(JSONArray)MethodInvoker.invoke(methodWrapper,false);
          }
          return jsonArray.toString();
        }
 else         if (returnObj instanceof JSONArray) {
          JSONArray jsonArray=(JSONArray)returnObj;
          return jsonArray.toString();
        }
 else         if (returnObj instanceof JSONObject) {
          JSONObject jsonObj=(JSONObject)returnObj;
          return jsonObj.toString();
        }
 else         if (returnObj instanceof Boolean || returnObj instanceof Double || returnObj instanceof Integer|| returnObj instanceof Long|| returnObj instanceof Short|| returnObj instanceof String) {
          JSONObject jsonObj=JSONFactoryUtil.createJSONObject();
          jsonObj.put("returnValue",returnObj.toString());
          return jsonObj.toString();
        }
 else {
          String returnValue=getReturnValue(returnObj);
          if (returnValue == null) {
            _log.error("Unsupported return type for class " + classObj + " and method "+ methodName);
          }
          return returnValue;
        }
      }
 else {
        JSONObject jsonObj=JSONFactoryUtil.createJSONObject();
        return jsonObj.toString();
      }
    }
 catch (    Exception e) {
      JSONObject jsonObj=JSONFactoryUtil.createJSONObject();
      if (e instanceof InvocationTargetException) {
        jsonObj.put("exception",e.getCause().toString());
      }
 else {
        jsonObj.put("exception",e.getMessage());
      }
      return jsonObj.toString();
    }
  }
  return null;
}
