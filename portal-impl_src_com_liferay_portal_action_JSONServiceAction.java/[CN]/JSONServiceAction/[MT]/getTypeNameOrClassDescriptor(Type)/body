{
  String typeName=type.toString();
  if (typeName.contains("class ")) {
    return typeName.substring(6);
  }
  Matcher matcher=_fieldDescriptorPattern.matcher(typeName);
  while (matcher.find()) {
    String dimensions=matcher.group(2);
    String fieldDescriptor=matcher.group(1);
    if (Validator.isNull(dimensions)) {
      return fieldDescriptor;
    }
    dimensions=dimensions.replace(StringPool.CLOSE_BRACKET,StringPool.BLANK);
    if (fieldDescriptor.equals("boolean")) {
      fieldDescriptor="Z";
    }
 else     if (fieldDescriptor.equals("byte")) {
      fieldDescriptor="B";
    }
 else     if (fieldDescriptor.equals("char")) {
      fieldDescriptor="C";
    }
 else     if (fieldDescriptor.equals("double")) {
      fieldDescriptor="D";
    }
 else     if (fieldDescriptor.equals("float")) {
      fieldDescriptor="F";
    }
 else     if (fieldDescriptor.equals("int")) {
      fieldDescriptor="I";
    }
 else     if (fieldDescriptor.equals("long")) {
      fieldDescriptor="J";
    }
 else     if (fieldDescriptor.equals("short")) {
      fieldDescriptor="S";
    }
 else {
      fieldDescriptor="L".concat(fieldDescriptor).concat(StringPool.SEMICOLON);
    }
    return dimensions.concat(fieldDescriptor);
  }
  throw new IllegalArgumentException(type.toString() + " is invalid");
}
