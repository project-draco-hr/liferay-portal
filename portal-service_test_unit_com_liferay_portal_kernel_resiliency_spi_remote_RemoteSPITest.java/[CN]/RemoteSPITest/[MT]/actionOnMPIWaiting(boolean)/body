{
  final Thread currentThread=Thread.currentThread();
  FutureTask<?> futureTask=new FutureTask<Object>(new Callable<Object>(){
    @Override public Object call() throws Exception {
      AbstractQueuedSynchronizer abstractQueuedSynchronizer=(AbstractQueuedSynchronizer)ReflectionTestUtil.getFieldValue(_mockRemoteSPI.countDownLatch,"sync");
      while (true) {
        Collection<Thread> threads=abstractQueuedSynchronizer.getQueuedThreads();
        if (threads.contains(currentThread)) {
          if (countDownOrInterrupt) {
            CountDownLatch countDownLatch=_mockRemoteSPI.countDownLatch;
            countDownLatch.countDown();
          }
 else {
            currentThread.interrupt();
          }
          break;
        }
      }
      return null;
    }
  }
);
  Thread thread=new Thread(futureTask);
  thread.start();
  return futureTask;
}
