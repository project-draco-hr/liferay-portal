{
  Set<Long> userIds=new HashSet<>();
  MBThread thread=mbThreadLocalService.getThread(threadId);
  List<MBMessage> messages=mbMessageLocalService.getThreadMessages(threadId,WorkflowConstants.STATUS_ANY);
  for (  MBMessage message : messages) {
    if (message.isDiscussion()) {
      continue;
    }
    int oldStatus=message.getStatus();
    message.setStatus(WorkflowConstants.STATUS_IN_TRASH);
    mbMessagePersistence.update(message);
    userIds.add(message.getUserId());
    int status=oldStatus;
    if (oldStatus == WorkflowConstants.STATUS_PENDING) {
      status=WorkflowConstants.STATUS_DRAFT;
    }
    if (oldStatus != WorkflowConstants.STATUS_APPROVED) {
      trashVersionLocalService.addTrashVersion(trashEntryId,MBMessage.class.getName(),message.getMessageId(),status,null);
    }
    if (oldStatus == WorkflowConstants.STATUS_APPROVED) {
      assetEntryLocalService.updateVisible(MBMessage.class.getName(),message.getMessageId(),false);
    }
    for (    FileEntry fileEntry : message.getAttachmentsFileEntries()) {
      PortletFileRepositoryUtil.movePortletFileEntryToTrash(thread.getStatusByUserId(),fileEntry.getFileEntryId());
    }
    Indexer<MBMessage> indexer=IndexerRegistryUtil.nullSafeGetIndexer(MBMessage.class);
    indexer.reindex(message);
    if (oldStatus == WorkflowConstants.STATUS_PENDING) {
      workflowInstanceLinkLocalService.deleteWorkflowInstanceLink(message.getCompanyId(),message.getGroupId(),MBMessage.class.getName(),message.getMessageId());
    }
  }
  for (  long userId : userIds) {
    mbStatsUserLocalService.updateStatsUser(groupId,userId);
  }
}
