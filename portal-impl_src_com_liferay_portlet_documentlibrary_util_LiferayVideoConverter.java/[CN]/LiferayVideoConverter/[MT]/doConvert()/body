{
  _inputIContainer=IContainer.make();
  _outputIContainer=IContainer.make();
  openContainer(_inputIContainer,_inputURL,false);
  openContainer(_outputIContainer,_outputURL,true);
  int inputStreamsCount=_inputIContainer.getNumStreams();
  if (inputStreamsCount < 0) {
    throw new RuntimeException("Input URL does not have any streams");
  }
  IAudioResampler[] iAudioResamplers=new IAudioResampler[inputStreamsCount];
  IVideoResampler[] iVideoResamplers=new IVideoResampler[inputStreamsCount];
  IAudioSamples[] inputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IAudioSamples[] outputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IVideoPicture[] inputIVideoPictures=new IVideoPicture[inputStreamsCount];
  IVideoPicture[] outputIVideoPictures=new IVideoPicture[inputStreamsCount];
  IStream[] outputIStreams=new IStream[inputStreamsCount];
  IStreamCoder[] inputIStreamCoders=new IStreamCoder[inputStreamsCount];
  IStreamCoder[] outputIStreamCoders=new IStreamCoder[inputStreamsCount];
  String outputFormat=_outputIContainer.getContainerFormat().getOutputFormatShortName();
  for (int i=0; i < inputStreamsCount; i++) {
    IStream inputIStream=_inputIContainer.getStream(i);
    IStreamCoder inputIStreamCoder=inputIStream.getStreamCoder();
    inputIStreamCoders[i]=inputIStreamCoder;
    ICodec.Type inputICodecType=inputIStreamCoder.getCodecType();
    if (inputICodecType == ICodec.Type.CODEC_TYPE_AUDIO) {
      prepareAudio(iAudioResamplers,inputIAudioSamples,outputIAudioSamples,inputIStreamCoder,outputIStreamCoders,_outputIContainer,outputIStreams,inputICodecType,_outputURL,i);
    }
 else     if (inputICodecType == ICodec.Type.CODEC_TYPE_VIDEO) {
      prepareVideo(iVideoResamplers,inputIVideoPictures,outputIVideoPictures,inputIStreamCoder,outputIStreamCoders,outputFormat,outputIStreams,inputICodecType,i);
    }
    openStreamCoder(inputIStreamCoders[i]);
    openStreamCoder(outputIStreamCoders[i]);
  }
  if (_outputIContainer.writeHeader() < 0) {
    throw new RuntimeException("Unable to write container header");
  }
  boolean keyPacketFound=false;
  int nonKeyAfterKeyCount=0;
  boolean onlyDecodeKeyPackets=false;
  int previousPacketSize=-1;
  IPacket inputIPacket=IPacket.make();
  IPacket outputIPacket=IPacket.make();
  while (_inputIContainer.readNextPacket(inputIPacket) == 0) {
    if (_log.isDebugEnabled()) {
      _log.debug("Current packet size " + inputIPacket.getSize());
    }
    int streamIndex=inputIPacket.getStreamIndex();
    IStreamCoder inputIStreamCoder=inputIStreamCoders[streamIndex];
    IStreamCoder outputIStreamCoder=outputIStreamCoders[streamIndex];
    if (outputIStreamCoder == null) {
      continue;
    }
    IStream iStream=_inputIContainer.getStream(streamIndex);
    long timeStampOffset=getStreamTimeStampOffset(iStream);
    if (inputIStreamCoder.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO) {
      decodeAudio(iAudioResamplers[streamIndex],inputIAudioSamples[streamIndex],outputIAudioSamples[streamIndex],inputIPacket,outputIPacket,inputIStreamCoder,outputIStreamCoder,_outputIContainer,inputIPacket.getSize(),previousPacketSize,streamIndex,timeStampOffset);
    }
 else     if (inputIStreamCoder.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO) {
      keyPacketFound=isKeyPacketFound(inputIPacket,keyPacketFound);
      nonKeyAfterKeyCount=countNonKeyAfterKey(inputIPacket,keyPacketFound,nonKeyAfterKeyCount);
      if (isStartDecoding(inputIPacket,inputIStreamCoder,keyPacketFound,nonKeyAfterKeyCount,onlyDecodeKeyPackets)) {
        int value=decodeVideo(iVideoResamplers[streamIndex],inputIVideoPictures[streamIndex],outputIVideoPictures[streamIndex],inputIPacket,outputIPacket,inputIStreamCoder,outputIStreamCoder,_outputIContainer,null,null,0,0,timeStampOffset);
        if (value <= 0) {
          if (inputIPacket.isKey()) {
            throw new RuntimeException("Unable to decode video stream " + streamIndex);
          }
          onlyDecodeKeyPackets=true;
          continue;
        }
      }
 else {
        if (_log.isDebugEnabled()) {
          _log.debug("Do not decode video stream " + streamIndex);
        }
      }
    }
    previousPacketSize=inputIPacket.getSize();
  }
  flush(outputIStreamCoders,_outputIContainer);
  if (_outputIContainer.writeTrailer() < 0) {
    throw new RuntimeException("Unable to write trailer to output file");
  }
  cleanUp(inputIStreamCoders,outputIStreamCoders);
  File videoFile=new File(_outputURL);
  if (outputFormat.equals("mp4") && videoFile.exists()) {
    File fastStartTmp=FileUtil.createTempFile();
    try {
      JQTFastStart.convert(videoFile,fastStartTmp);
      if (fastStartTmp.exists() && fastStartTmp.length() > 0) {
        FileUtil.move(fastStartTmp,videoFile);
      }
    }
 catch (    Exception e) {
      if (_log.isWarnEnabled()) {
        _log.warn("Error while moving MOOV atom to front of MP4 file.");
      }
    }
 finally {
      FileUtil.delete(fastStartTmp);
    }
  }
}
