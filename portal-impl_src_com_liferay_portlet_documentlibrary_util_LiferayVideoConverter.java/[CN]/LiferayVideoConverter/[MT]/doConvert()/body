{
  _inputIContainer=IContainer.make();
  _outputIContainer=IContainer.make();
  openContainer(_inputIContainer,_inputURL,false);
  openContainer(_outputIContainer,_outputURL,true);
  int inputStreamsCount=_inputIContainer.getNumStreams();
  if (inputStreamsCount < 0) {
    throw new RuntimeException("Input URL does not have any streams");
  }
  IAudioResampler[] iAudioResamplers=new IAudioResampler[inputStreamsCount];
  IVideoResampler[] iVideoResamplers=new IVideoResampler[inputStreamsCount];
  IAudioSamples[] inputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IAudioSamples[] outputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IVideoPicture[] inputIVideoPictures=new IVideoPicture[inputStreamsCount];
  IVideoPicture[] outputIVideoPictures=new IVideoPicture[inputStreamsCount];
  IStream[] outputIStreams=new IStream[inputStreamsCount];
  IStreamCoder[] inputIStreamCoders=new IStreamCoder[inputStreamsCount];
  IStreamCoder[] outputIStreamCoders=new IStreamCoder[inputStreamsCount];
  String outputFormat=_outputIContainer.getContainerFormat().getOutputFormatShortName();
  for (int i=0; i < inputStreamsCount; i++) {
    IStream inputIStream=_inputIContainer.getStream(i);
    IStreamCoder inputIStreamCoder=inputIStream.getStreamCoder();
    inputIStreamCoders[i]=inputIStreamCoder;
    ICodec.Type inputICodecType=inputIStreamCoder.getCodecType();
    if (inputICodecType == ICodec.Type.CODEC_TYPE_AUDIO) {
      int channels=inputIStreamCoder.getChannels();
      if (_channels > 0) {
        channels=_channels;
      }
      int rate=inputIStreamCoder.getSampleRate();
      if (_rate > 0) {
        rate=_rate;
      }
      prepareAudio(iAudioResamplers,inputIAudioSamples,outputIAudioSamples,inputIStreamCoder,outputIStreamCoders,_outputIContainer,outputIStreams,inputICodecType,_outputURL,channels,rate,i);
    }
 else     if (inputICodecType == ICodec.Type.CODEC_TYPE_VIDEO) {
      IStream outputIStream=_outputIContainer.addNewStream(i);
      outputIStreams[i]=outputIStream;
      IStreamCoder outputIStreamCoder=outputIStream.getStreamCoder();
      outputIStreamCoders[i]=outputIStreamCoder;
      if (inputIStreamCoder.getBitRate() == 0) {
        outputIStreamCoder.setBitRate(250000);
      }
 else {
        outputIStreamCoder.setBitRate(inputIStreamCoder.getBitRate());
      }
      ICodec iCodec=ICodec.guessEncodingCodec(null,null,_outputURL,null,inputICodecType);
      if (outputFormat.equals("mp4")) {
        iCodec=ICodec.findEncodingCodec(ICodec.ID.CODEC_ID_H264);
      }
      if (iCodec == null) {
        throw new RuntimeException("Unable to determine " + inputICodecType + " encoder for "+ _outputURL);
      }
      outputIStreamCoder.setCodec(iCodec);
      if (inputIStreamCoder.getHeight() <= 0) {
        throw new RuntimeException("Unable to determine height for " + _inputURL);
      }
      outputIStreamCoder.setHeight(_height);
      IRational iRational=inputIStreamCoder.getFrameRate();
      outputIStreamCoder.setFrameRate(iRational);
      outputIStreamCoder.setPixelType(Type.YUV420P);
      outputIStreamCoder.setTimeBase(IRational.make(iRational.getDenominator(),iRational.getNumerator()));
      if (inputIStreamCoder.getWidth() <= 0) {
        throw new RuntimeException("Unable to determine width for " + _inputURL);
      }
      outputIStreamCoder.setWidth(_width);
      iVideoResamplers[i]=createIVideoResampler(inputIStreamCoder,outputIStreamCoder,_height,_width);
      inputIVideoPictures[i]=IVideoPicture.make(inputIStreamCoder.getPixelType(),inputIStreamCoder.getWidth(),inputIStreamCoder.getHeight());
      outputIVideoPictures[i]=IVideoPicture.make(outputIStreamCoder.getPixelType(),outputIStreamCoder.getWidth(),outputIStreamCoder.getHeight());
      if (iCodec.getID().equals(ICodec.ID.CODEC_ID_H264)) {
        Configuration.configure(_ffpresetProperties,outputIStreamCoder);
      }
    }
    openStreamCoder(inputIStreamCoders[i]);
    openStreamCoder(outputIStreamCoders[i]);
  }
  if (_outputIContainer.writeHeader() < 0) {
    throw new RuntimeException("Unable to write container header");
  }
  boolean keyPacketFound=false;
  int nonKeyAfterKeyCount=0;
  boolean onlyDecodeKeyPackets=false;
  int previousPacketSize=-1;
  IPacket inputIPacket=IPacket.make();
  IPacket outputIPacket=IPacket.make();
  while (_inputIContainer.readNextPacket(inputIPacket) == 0) {
    if (_log.isDebugEnabled()) {
      _log.debug("Current packet size " + inputIPacket.getSize());
    }
    int streamIndex=inputIPacket.getStreamIndex();
    IStreamCoder inputIStreamCoder=inputIStreamCoders[streamIndex];
    IStreamCoder outputIStreamCoder=outputIStreamCoders[streamIndex];
    if (outputIStreamCoder == null) {
      continue;
    }
    IStream iStream=_inputIContainer.getStream(streamIndex);
    long timeStampOffset=getStreamTimeStampOffset(iStream);
    if (inputIStreamCoder.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO) {
      decodeAudio(iAudioResamplers[streamIndex],inputIAudioSamples[streamIndex],outputIAudioSamples[streamIndex],inputIPacket,outputIPacket,inputIStreamCoder,outputIStreamCoder,_outputIContainer,inputIPacket.getSize(),previousPacketSize,streamIndex,timeStampOffset);
    }
 else     if (inputIStreamCoder.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO) {
      keyPacketFound=isKeyPacketFound(inputIPacket,keyPacketFound);
      nonKeyAfterKeyCount=countNonKeyAfterKey(inputIPacket,keyPacketFound,nonKeyAfterKeyCount);
      if (isStartDecoding(inputIPacket,inputIStreamCoder,keyPacketFound,nonKeyAfterKeyCount,onlyDecodeKeyPackets)) {
        int value=decodeVideo(iVideoResamplers[streamIndex],inputIVideoPictures[streamIndex],outputIVideoPictures[streamIndex],inputIPacket,outputIPacket,inputIStreamCoder,outputIStreamCoder,_outputIContainer,null,null,0,0,timeStampOffset);
        if (value <= 0) {
          if (inputIPacket.isKey()) {
            throw new RuntimeException("Unable to decode video stream " + streamIndex);
          }
          onlyDecodeKeyPackets=true;
          continue;
        }
      }
 else {
        if (_log.isDebugEnabled()) {
          _log.debug("Do not decode video stream " + streamIndex);
        }
      }
    }
    previousPacketSize=inputIPacket.getSize();
  }
  flush(outputIStreamCoders,_outputIContainer);
  if (_outputIContainer.writeTrailer() < 0) {
    throw new RuntimeException("Unable to write trailer to output file");
  }
  cleanUp(inputIStreamCoders,outputIStreamCoders);
  File videoFile=new File(_outputURL);
  if (outputFormat.equals("mp4") && videoFile.exists()) {
    File fastStartTmp=FileUtil.createTempFile();
    try {
      JQTFastStart.convert(videoFile,fastStartTmp);
      if (fastStartTmp.exists() && fastStartTmp.length() > 0) {
        FileUtil.move(fastStartTmp,videoFile);
      }
    }
 catch (    Exception e) {
      if (_log.isWarnEnabled()) {
        _log.warn("Error while moving MOOV atom to front of MP4 file.");
      }
    }
 finally {
      FileUtil.delete(fastStartTmp);
    }
  }
}
