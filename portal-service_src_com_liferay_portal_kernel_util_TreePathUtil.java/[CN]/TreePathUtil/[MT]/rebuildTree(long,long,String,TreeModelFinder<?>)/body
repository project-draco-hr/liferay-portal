{
  if (parentTreePath.equals(StringPool.SLASH)) {
    treeModelFinder.rebuildDependentModelsTreePaths(parentPrimaryKey,"/0/");
  }
 else {
    treeModelFinder.rebuildDependentModelsTreePaths(parentPrimaryKey,parentTreePath);
  }
  List<TreeModel> modifiedTreeModels=new ArrayList<TreeModel>();
  int size=GetterUtil.getInteger(PropsUtil.get(PropsKeys.MODEL_TREE_REBUILD_QUERY_RESULTS_BATCH_SIZE));
  Deque<Object[]> traces=new LinkedList<Object[]>();
  traces.push(new Object[]{parentPrimaryKey,parentTreePath,0L});
  Object[] trace=null;
  while ((trace=traces.poll()) != null) {
    Long curParentPrimaryKey=(Long)trace[0];
    String curParentTreePath=(String)trace[1];
    Long previousPrimaryKey=(Long)trace[2];
    List<? extends TreeModel> treeModels=treeModelFinder.findTreeModels(previousPrimaryKey,companyId,curParentPrimaryKey,size);
    if (treeModels.isEmpty()) {
      continue;
    }
    if (treeModels.size() == size) {
      TreeModel treeModel=treeModels.get(treeModels.size() - 1);
      trace[2]=treeModel.getPrimaryKeyObj();
      traces.push(trace);
    }
    for (    TreeModel treeModel : treeModels) {
      String treePath=curParentTreePath.concat(String.valueOf(treeModel.getPrimaryKeyObj())).concat(StringPool.SLASH);
      treeModel.updateTreePath(treePath);
      treeModelFinder.rebuildDependentModelsTreePaths((Long)treeModel.getPrimaryKeyObj(),treePath);
      traces.push(new Object[]{treeModel.getPrimaryKeyObj(),treePath,0L});
      modifiedTreeModels.add(treeModel);
    }
  }
  treeModelFinder.reindexTreeModels(modifiedTreeModels);
}
