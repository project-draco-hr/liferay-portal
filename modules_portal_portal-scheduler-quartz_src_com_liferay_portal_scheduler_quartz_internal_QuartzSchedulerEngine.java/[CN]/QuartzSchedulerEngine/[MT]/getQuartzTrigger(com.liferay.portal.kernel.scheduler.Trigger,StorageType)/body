{
  if (trigger == null) {
    return null;
  }
  Date endDate=trigger.getEndDate();
  String jobName=fixMaxLength(trigger.getJobName(),_jobNameMaxLength,storageType);
  String groupName=fixMaxLength(trigger.getGroupName(),_groupNameMaxLength,storageType);
  Date startDate=trigger.getStartDate();
  if (startDate == null) {
    startDate=new Date(System.currentTimeMillis());
  }
  TriggerBuilder<Trigger> triggerBuilder=TriggerBuilder.newTrigger();
  triggerBuilder.endAt(endDate);
  triggerBuilder.forJob(jobName,groupName);
  triggerBuilder.startAt(startDate);
  triggerBuilder.withIdentity(jobName,groupName);
  TriggerType triggerType=trigger.getTriggerType();
  if (triggerType == TriggerType.CRON) {
    triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule((String)trigger.getTriggerContent()));
    return triggerBuilder.build();
  }
  ObjectValuePair<Integer,TimeUnit> objectValuePair=(ObjectValuePair<Integer,TimeUnit>)trigger.getTriggerContent();
  int interval=objectValuePair.getKey();
  if (interval < 0) {
    if (_log.isWarnEnabled()) {
      _log.warn("Not scheduling " + trigger.getJobName() + " because interval is less than 0");
    }
    return null;
  }
 else   if (interval == 0) {
    return triggerBuilder.build();
  }
  TimeUnit timeUnit=objectValuePair.getValue();
  if (timeUnit == TimeUnit.MILLISECOND) {
    SimpleScheduleBuilder simpleScheduleBuilder=SimpleScheduleBuilder.simpleSchedule();
    simpleScheduleBuilder.withIntervalInMilliseconds(interval);
    simpleScheduleBuilder.withRepeatCount(SimpleTrigger.REPEAT_INDEFINITELY);
    triggerBuilder.withSchedule(simpleScheduleBuilder);
  }
 else {
    CalendarIntervalScheduleBuilder calendarIntervalScheduleBuilder=CalendarIntervalScheduleBuilder.calendarIntervalSchedule();
    calendarIntervalScheduleBuilder.withInterval(interval,IntervalUnit.valueOf(timeUnit.name()));
    triggerBuilder.withSchedule(calendarIntervalScheduleBuilder);
  }
  return triggerBuilder.build();
}
