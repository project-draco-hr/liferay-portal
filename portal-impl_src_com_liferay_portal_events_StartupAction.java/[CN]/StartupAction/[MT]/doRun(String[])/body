{
  System.out.println("Starting " + ReleaseInfo.getReleaseInfo());
  try {
    LockServiceUtil.clear();
  }
 catch (  Exception e) {
    _log.error(e,e);
  }
  Runtime.getRuntime().addShutdownHook(new Thread(new ShutdownHook()));
  LiferayResourceLoader.setListeners(PropsUtil.getArray(PropsKeys.VELOCITY_ENGINE_RESOURCE_LISTENERS));
  ExtendedProperties props=new ExtendedProperties();
  props.setProperty(RuntimeConstants.RESOURCE_LOADER,"servlet");
  props.setProperty("servlet." + RuntimeConstants.RESOURCE_LOADER + ".class",LiferayResourceLoader.class.getName());
  props.setProperty(RuntimeConstants.RESOURCE_MANAGER_CLASS,PropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER));
  props.setProperty(RuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS,PropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER_CACHE));
  props.setProperty("velocimacro.library",PropsUtil.get(PropsKeys.VELOCITY_ENGINE_VELOCIMACRO_LIBRARY));
  props.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS,PropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER));
  props.setProperty("runtime.log.logsystem.log4j.category",PropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER_CATEGORY));
  Velocity.setExtendedProperties(props);
  try {
    Velocity.init();
  }
 catch (  Exception e) {
    _log.error(e,e);
  }
  CacheRegistry.setActive(false);
  int buildNumber=ReleaseLocalServiceUtil.getBuildNumberOrCreate();
  if (buildNumber < ReleaseInfo.RELEASE_4_2_1_BUILD_NUMBER) {
    String msg="You must first upgrade to Liferay Portal 4.2.1";
    _log.fatal(msg);
    throw new RuntimeException(msg);
  }
  boolean ranUpgradeProcess=false;
  String[] upgradeProcesses=PropsUtil.getArray(PropsKeys.UPGRADE_PROCESSES);
  for (int i=0; i < upgradeProcesses.length; i++) {
    if (_log.isDebugEnabled()) {
      _log.debug("Initializing upgrade " + upgradeProcesses[i]);
    }
    UpgradeProcess upgradeProcess=(UpgradeProcess)InstancePool.get(upgradeProcesses[i]);
    if (upgradeProcess == null) {
      _log.error(upgradeProcesses[i] + " cannot be found");
      continue;
    }
    if ((upgradeProcess.getThreshold() == 0) || (upgradeProcess.getThreshold() > buildNumber)) {
      if (_log.isInfoEnabled()) {
        _log.info("Running upgrade " + upgradeProcesses[i]);
      }
      upgradeProcess.upgrade();
      if (_log.isInfoEnabled()) {
        _log.info("Finished upgrade " + upgradeProcesses[i]);
      }
      ranUpgradeProcess=true;
    }
 else {
      if (_log.isDebugEnabled()) {
        _log.debug("Upgrade threshold " + upgradeProcess.getThreshold() + " will not trigger upgrade");
        _log.debug("Skipping upgrade " + upgradeProcesses[i]);
      }
    }
  }
  ClassNameLocalServiceUtil.checkClassNames();
  try {
    deleteTemporaryImages();
  }
 catch (  Exception e) {
    _log.error(e,e);
  }
  if (ranUpgradeProcess) {
    try {
      DBUtil.getInstance().runSQLTemplate("indexes.sql",false);
    }
 catch (    Exception e) {
      _log.error(e,e);
    }
  }
  CacheRegistry.setActive(true);
  if (ranUpgradeProcess) {
    MultiVMPoolUtil.clear();
  }
  MessageBus messageBus=(MessageBus)PortalBeanLocatorUtil.locate(MessageBus.class.getName());
  MessageSender messageSender=(MessageSender)PortalBeanLocatorUtil.locate(MessageSender.class.getName());
  SynchronousMessageSender synchronousMessageSender=(SynchronousMessageSender)PortalBeanLocatorUtil.locate(SynchronousMessageSender.class.getName());
  MessageBusUtil.init(messageBus,messageSender,synchronousMessageSender);
  SchedulerEngineUtil.init(new SchedulerEngineProxy());
  SchedulerEngineUtil.start();
  Release release=ReleaseLocalServiceUtil.getRelease();
  int verifyFrequency=GetterUtil.getInteger(PropsUtil.get(PropsKeys.VERIFY_FREQUENCY));
  boolean verified=release.isVerified();
  if ((verifyFrequency == VerifyProcess.ALWAYS) || ((verifyFrequency == VerifyProcess.ONCE) && !verified) || (ranUpgradeProcess)) {
    if (!ranUpgradeProcess) {
      PropsUtil.set(PropsKeys.INDEX_ON_STARTUP,"true");
    }
    String[] verifyProcesses=PropsUtil.getArray(PropsKeys.VERIFY_PROCESSES);
    for (int i=0; i < verifyProcesses.length; i++) {
      if (_log.isDebugEnabled()) {
        _log.debug("Initializing verification " + verifyProcesses[i]);
      }
      try {
        VerifyProcess verifyProcess=(VerifyProcess)Class.forName(verifyProcesses[i]).newInstance();
        if (_log.isInfoEnabled()) {
          _log.info("Running verification " + verifyProcesses[i]);
        }
        verifyProcess.verify();
        if (_log.isInfoEnabled()) {
          _log.info("Finished verification " + verifyProcesses[i]);
        }
        verified=true;
      }
 catch (      ClassNotFoundException cnfe) {
        _log.error(verifyProcesses[i] + " cannot be found");
      }
catch (      IllegalAccessException iae) {
        _log.error(verifyProcesses[i] + " cannot be accessed");
      }
catch (      InstantiationException ie) {
        _log.error(verifyProcesses[i] + " cannot be initiated");
      }
    }
  }
  ReleaseLocalServiceUtil.updateRelease(verified);
}
