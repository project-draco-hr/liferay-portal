{
  final Project project=getProject();
  final File temporaryDir=getTemporaryDir();
  project.delete(temporaryDir);
  temporaryDir.mkdir();
  Closure<Void> closure=new Closure<Void>(null){
    @SuppressWarnings("unused") public void doCall(    CopySpec copySpec) throws Exception {
      final String originalLibSrcDirName=getOriginalLibSrcDirName();
      if (!originalLibSrcDirName.equals(".")) {
        Map<Object,Object> leadingPathReplacementsMap=new HashMap<>();
        leadingPathReplacementsMap.put(originalLibSrcDirName,"");
        copySpec.eachFile(new ReplaceLeadingPathAction(leadingPathReplacementsMap));
      }
      copySpec.filter(FixCrLfFilter.class);
      copySpec.from(project.zipTree(getOriginalLibSrcFile()));
      copySpec.include(getFileNames());
      copySpec.into(temporaryDir);
      copySpec.setIncludeEmptyDirs(false);
    }
  }
;
  project.copy(closure);
  for (  final File patchFile : getSortedPatchFiles()) {
    final ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
    project.exec(new Action<ExecSpec>(){
      @Override public void execute(      ExecSpec execSpec){
        execSpec.setExecutable("patch");
        execSpec.setWorkingDir(temporaryDir);
        execSpec.args("--binary");
        execSpec.args("--input=" + FileUtil.relativize(patchFile,temporaryDir));
        execSpec.args("--strip=1");
        execSpec.setStandardOutput(byteArrayOutputStream);
      }
    }
);
    System.out.println(byteArrayOutputStream.toString());
  }
  FileTree fileTree=project.fileTree(temporaryDir);
  for (  File file : fileTree) {
    File patchedSrcDir=getPatchedSrcDir(file.getName());
    if (patchedSrcDir == null) {
      continue;
    }
    Path patchedSrcDirPath=patchedSrcDir.toPath();
    String relativePath=FileUtil.relativize(file,temporaryDir);
    patchedSrcDirPath=patchedSrcDirPath.resolve(relativePath);
    Files.createDirectories(patchedSrcDirPath.getParent());
    Files.move(file.toPath(),patchedSrcDirPath,StandardCopyOption.REPLACE_EXISTING);
  }
}
