{
  long start=System.currentTimeMillis();
  int retryCount=0;
  while (true) {
    String baseInvocationURL=properties.getProperty("base.invocation.url");
    String hostNamePrefix=getHostNamePrefix(baseInvocationURL);
    if (hostNamePrefix.equals(baseInvocationURL)) {
      return baseInvocationURL;
    }
    List<String> hostNames=getHostNames(properties,hostNamePrefix);
    if (hostNames.size() == 1) {
      return "http://" + hostNamePrefix + "-1";
    }
    int maxAvailableSlaveCount=Integer.MIN_VALUE;
    int x=-1;
    try {
      List<FutureTask<Integer>> futureTasks=new ArrayList<>(hostNames.size());
      startParallelTasks(hostNames,hostNamePrefix,properties,futureTasks);
      List<Integer> badIndices=new ArrayList<>(futureTasks.size());
      List<Integer> maxIndices=new ArrayList<>(futureTasks.size());
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < futureTasks.size(); i++) {
        Integer availableSlaveCount=null;
        FutureTask<Integer> futureTask=futureTasks.get(i);
        try {
          availableSlaveCount=futureTask.get(15,TimeUnit.SECONDS);
        }
 catch (        TimeoutException te) {
          System.out.println("Unable to assess master availability for " + hostNames.get(i) + ".");
          availableSlaveCount=null;
        }
        if (availableSlaveCount == null) {
          badIndices.add(i);
          continue;
        }
        sb.append(hostNames.get(i));
        sb.append(" : ");
        sb.append(availableSlaveCount);
        sb.append("\n");
        if (availableSlaveCount > maxAvailableSlaveCount) {
          maxAvailableSlaveCount=availableSlaveCount;
          maxIndices.clear();
        }
        if (availableSlaveCount >= maxAvailableSlaveCount) {
          maxIndices.add(i);
        }
      }
      if (maxAvailableSlaveCount == Integer.MIN_VALUE) {
        if (retryCount == 3) {
          throw new RuntimeException("Retry limit exceeded. Unable to communicate " + " with masters.");
        }
        retryCount++;
        continue;
      }
      if (maxIndices.size() > 0) {
        x=maxIndices.get(getRandomValue(0,maxIndices.size() - 1));
      }
 else {
        while (true) {
          x=getRandomValue(0,hostNames.size() - 1);
          if (badIndices.contains(x)) {
            continue;
          }
          break;
        }
      }
      sb.append("\nMost available master ");
      sb.append(hostNames.get(x));
      sb.append(" has ");
      sb.append(maxAvailableSlaveCount);
      sb.append(" available slaves.");
      System.out.println(sb);
      return "http://" + hostNames.get(x);
    }
  finally {
      if (recentJobPeriod > 0) {
        StringBuilder sb=new StringBuilder();
        String recentJobs=_recentJobsMap.get(hostNames.get(x));
        if (recentJobs == null) {
          recentJobs="";
        }
        sb.append(recentJobs);
        if (sb.length() > 0) {
          sb.append("|");
        }
        int invokedJobBatchSize=0;
        try {
          invokedJobBatchSize=Integer.parseInt(properties.getProperty("invoked.job.batch.size"));
        }
 catch (        Exception e) {
          invokedJobBatchSize=1;
        }
        if (invokedJobBatchSize != 0) {
          sb.append(invokedJobBatchSize);
          sb.append("-");
          sb.append(System.currentTimeMillis());
          System.out.println(sb);
          _recentJobsMap.put(hostNames.get(x),sb.toString());
        }
      }
      System.out.println("Got most available master URL in " + ((System.currentTimeMillis() - start) / 1000F) + " seconds.");
    }
  }
}
