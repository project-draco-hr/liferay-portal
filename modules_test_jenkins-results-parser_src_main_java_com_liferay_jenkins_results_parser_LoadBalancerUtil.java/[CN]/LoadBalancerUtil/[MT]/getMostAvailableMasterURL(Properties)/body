{
  long start=System.currentTimeMillis();
  int retryCount=0;
  while (true) {
    String baseInvocationURL=properties.getProperty("base.invocation.url");
    String masterPrefix=getMasterPrefix(baseInvocationURL);
    if (masterPrefix.equals(baseInvocationURL)) {
      return baseInvocationURL;
    }
    List<String> masters=getMasters(masterPrefix,properties);
    if (masters.size() == 1) {
      return "http://" + masterPrefix + "-1";
    }
    int maxAvailableSlaveCount=Integer.MIN_VALUE;
    int x=-1;
    try {
      List<FutureTask<Integer>> futureTasks=new ArrayList<>(masters.size());
      startParallelTasks(futureTasks,masters,masterPrefix,properties);
      List<Integer> badIndices=new ArrayList<>(futureTasks.size());
      List<Integer> maxIndices=new ArrayList<>(futureTasks.size());
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < futureTasks.size(); i++) {
        Integer availableSlaveCount=null;
        FutureTask<Integer> futureTask=futureTasks.get(i);
        try {
          availableSlaveCount=futureTask.get(15,TimeUnit.SECONDS);
        }
 catch (        TimeoutException te) {
          System.out.println("Unable to assess master availability for " + masters.get(i) + ".");
          availableSlaveCount=null;
        }
        if (availableSlaveCount == null) {
          badIndices.add(i);
          continue;
        }
        sb.append(masters.get(i));
        sb.append(" : ");
        sb.append(availableSlaveCount);
        sb.append("\n");
        if (availableSlaveCount > maxAvailableSlaveCount) {
          maxAvailableSlaveCount=availableSlaveCount;
          maxIndices.clear();
        }
        if (availableSlaveCount >= maxAvailableSlaveCount) {
          maxIndices.add(i);
        }
      }
      if (maxAvailableSlaveCount == Integer.MIN_VALUE) {
        if (retryCount == 3) {
          throw new RuntimeException("Retry limit exceeded. Unable to communicate " + " with masters.");
        }
        retryCount++;
        continue;
      }
      if (maxIndices.size() > 0) {
        x=maxIndices.get(getRandomValue(0,maxIndices.size() - 1));
      }
 else {
        while (true) {
          x=getRandomValue(0,masters.size() - 1);
          if (badIndices.contains(x)) {
            continue;
          }
          break;
        }
      }
      sb.append("\nMost available master ");
      sb.append(masters.get(x));
      sb.append(" has ");
      sb.append(maxAvailableSlaveCount);
      sb.append(" available slaves.");
      System.out.println(sb);
      return "http://" + masters.get(x);
    }
  finally {
      if (recentBatchPeriod > 0) {
        List<BatchSizeRecord> recentBatchSizeRecords=_recentBatchSizeRecordsMap.get(masters.get(x));
        if (recentBatchSizeRecords == null) {
          recentBatchSizeRecords=new ArrayList<>();
          _recentBatchSizeRecordsMap.put(masters.get(x),recentBatchSizeRecords);
        }
        int invokedBatchSize=0;
        try {
          invokedBatchSize=Integer.parseInt(properties.getProperty("invoked.job.batch.size"));
        }
 catch (        Exception e) {
          invokedBatchSize=1;
        }
        if (invokedBatchSize != 0) {
          recentBatchSizeRecords.add(new BatchSizeRecord(invokedBatchSize,System.currentTimeMillis()));
        }
      }
      System.out.println("Got most available master URL in " + ((System.currentTimeMillis() - start) / 1000F) + " seconds.");
    }
  }
}
