{
  TestClass testClass=(TestClass)Whitebox.getInternalState(this,"testClass",MethodValidator.class);
  Class<?> classUnderTest=(Class<?>)Whitebox.getInternalState(testClass,"klass");
  final List<Method> methods;
  if (TestCase.class.equals(classUnderTest.getSuperclass()) && !isStatic) {
    methods=getTestMethodsWithNoAnnotation(classUnderTest);
  }
 else {
    methods=testClass.getAnnotatedMethods(annotation);
  }
  List<Throwable> fErrors=(List<Throwable>)Whitebox.getInternalState(this,"errors",MethodValidator.class);
  for (  Method each : methods) {
    if (Modifier.isStatic(each.getModifiers()) != isStatic) {
      String state=isStatic ? "should" : "should not";
      fErrors.add(new Exception("Method " + each.getName() + "() "+ state+ " be static"));
    }
    if (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))     fErrors.add(new Exception("Class " + each.getDeclaringClass().getName() + " should be public"));
    if (!Modifier.isPublic(each.getModifiers()))     fErrors.add(new Exception("Method " + each.getName() + " should be public"));
    if (each.getReturnType() != Void.TYPE)     fErrors.add(new Exception("Method " + each.getName() + " should be void"));
    if (each.getParameterTypes().length != 0)     fErrors.add(new Exception("Method " + each.getName() + " should have no parameters"));
  }
}
