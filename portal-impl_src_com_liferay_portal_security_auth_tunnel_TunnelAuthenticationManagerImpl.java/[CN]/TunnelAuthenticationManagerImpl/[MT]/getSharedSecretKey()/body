{
  String sharedSecret=PropsValues.TUNNELING_SERVLET_SHARED_SECRET;
  boolean sharedSecretHex=PropsValues.TUNNELING_SERVLET_SHARED_SECRET_HEX;
  if (Validator.isNull(sharedSecret)) {
    String message="Please configure " + PropsKeys.TUNNELING_SERVLET_SHARED_SECRET;
    if (_log.isWarnEnabled()) {
      _log.warn(message);
    }
    AuthException authException=new AuthException(message);
    authException.setType(AuthException.NO_SHARED_SECRET);
    throw authException;
  }
  byte[] key=null;
  if (sharedSecretHex) {
    try {
      key=Hex.decodeHex(sharedSecret.toCharArray());
    }
 catch (    DecoderException e) {
      if (_log.isWarnEnabled()) {
        _log.warn(e,e);
      }
      AuthException authException=new AuthException();
      authException.setType(AuthException.INVALID_SHARED_SECRET);
      throw authException;
    }
  }
 else {
    key=sharedSecret.getBytes();
  }
  if (key.length < 8) {
    String message=PropsKeys.TUNNELING_SERVLET_SHARED_SECRET + " is too short";
    if (_log.isWarnEnabled()) {
      _log.warn(message);
    }
    AuthException authException=new AuthException(message);
    authException.setType(AuthException.INVALID_SHARED_SECRET);
    throw authException;
  }
  if (StringUtil.equalsIgnoreCase(PropsValues.TUNNELING_SERVLET_ENCRYPTION_ALGORITHM,"AES") && (key.length != 16) && (key.length != 32)) {
    String message=PropsKeys.TUNNELING_SERVLET_SHARED_SECRET + " must have 16 or 32 bytes when used with AES";
    if (_log.isWarnEnabled()) {
      _log.warn(message);
    }
    AuthException authException=new AuthException(message);
    authException.setType(AuthException.INVALID_SHARED_SECRET);
    throw authException;
  }
  return new SecretKeySpec(key,PropsValues.TUNNELING_SERVLET_ENCRYPTION_ALGORITHM);
}
