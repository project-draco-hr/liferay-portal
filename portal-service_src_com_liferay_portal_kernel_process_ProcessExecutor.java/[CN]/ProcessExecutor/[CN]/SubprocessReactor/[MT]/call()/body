{
  ProcessCallable<?> resultProcessCallable=null;
  UnsyncBufferedInputStream unsyncBufferedInputStream=new UnsyncBufferedInputStream(_process.getInputStream());
  try {
    ObjectInputStream objectInputStream=null;
    UnsyncByteArrayOutputStream unsyncByteArrayOutputStream=new UnsyncByteArrayOutputStream();
    while (true) {
      try {
        unsyncBufferedInputStream.mark(4);
        objectInputStream=new ClassLoaderObjectInputStream(unsyncBufferedInputStream,PortalClassLoaderUtil.getClassLoader());
        if (unsyncByteArrayOutputStream.size() > 0) {
          if (_log.isWarnEnabled()) {
            _log.warn("Found corrupt leading log " + unsyncByteArrayOutputStream.toString());
          }
        }
        unsyncByteArrayOutputStream=null;
        break;
      }
 catch (      StreamCorruptedException sce) {
        unsyncBufferedInputStream.reset();
        unsyncByteArrayOutputStream.write(unsyncBufferedInputStream.read());
      }
    }
    while (true) {
      ProcessCallable<?> processCallable=(ProcessCallable<?>)objectInputStream.readObject();
      if ((processCallable instanceof ExceptionProcessCallable) || (processCallable instanceof ReturnProcessCallable<?>)) {
        resultProcessCallable=processCallable;
        continue;
      }
      Serializable returnValue=processCallable.call();
      if (_log.isDebugEnabled()) {
        _log.debug("Invoked generic process callable " + processCallable + " with return value "+ returnValue);
      }
    }
  }
 catch (  StreamCorruptedException sce) {
    File file=File.createTempFile("corrupted-stream-dump-" + System.currentTimeMillis(),".log");
    _log.error("Dumping content of corrupted object input stream to " + file.getAbsolutePath(),sce);
    FileOutputStream fileOutputStream=new FileOutputStream(file);
    StreamUtil.transfer(unsyncBufferedInputStream,fileOutputStream);
    throw new ProcessException("Corrupted object input stream",sce);
  }
catch (  EOFException eofe) {
    throw new ProcessException("Subprocess piping back ended prematurely",eofe);
  }
 finally {
    try {
      int exitCode=_process.waitFor();
      if (exitCode != 0) {
        throw new ProcessException("Subprocess terminated with exit code " + exitCode);
      }
    }
 catch (    InterruptedException ie) {
      _process.destroy();
      throw new ProcessException("Forcibly killed subprocess on interruption",ie);
    }
    _managedProcesses.remove(_process);
    if (resultProcessCallable != null) {
      return resultProcessCallable;
    }
  }
}
