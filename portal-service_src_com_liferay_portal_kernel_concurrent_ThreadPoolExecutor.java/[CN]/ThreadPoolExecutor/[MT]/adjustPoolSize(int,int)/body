{
  if (newCorePoolSize < 0 || newMaxPoolSize <= 0 || newMaxPoolSize < newCorePoolSize) {
    throw new IllegalArgumentException();
  }
  _mainLock.lock();
  try {
    int surplusCoreThreads=_corePoolSize - newCorePoolSize;
    int surplusMaxPoolSize=_maxPoolSize - newMaxPoolSize;
    _corePoolSize=newCorePoolSize;
    _maxPoolSize=newMaxPoolSize;
    if ((surplusCoreThreads > 0 && _poolSize > _corePoolSize) || (surplusMaxPoolSize > 0 && _poolSize > _maxPoolSize)) {
      int interruptCount=Math.max(surplusCoreThreads,surplusMaxPoolSize);
      for (      WorkerTask workerTask : _workerTaskSet) {
        if (interruptCount > 0) {
          if (workerTask._interruptIfWaiting()) {
            interruptCount--;
          }
        }
 else {
          break;
        }
      }
    }
 else {
      Runnable task=null;
      while (surplusCoreThreads++ < 0 && _poolSize < _corePoolSize && (task=_taskQueue.poll()) != null) {
        _doAddWorkerThread(task);
      }
    }
  }
  finally {
    _mainLock.unlock();
  }
}
