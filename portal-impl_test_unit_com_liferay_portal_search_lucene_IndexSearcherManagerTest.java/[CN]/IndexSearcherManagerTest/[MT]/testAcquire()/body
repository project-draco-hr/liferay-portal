{
  IndexSearcher indexSearcher=_indexSearcherManager.acquire();
  IndexReader indexReader=indexSearcher.getIndexReader();
  int referenceCount=indexReader.getRefCount();
  Assert.assertSame(indexSearcher,_indexSearcherManager.acquire());
  Assert.assertEquals(referenceCount + 1,indexReader.getRefCount());
  final String fieldValue="testvalue";
  _addDocument(fieldValue);
  _indexSearcherManager.invalidate();
  SyncThrowableThread<Void> syncThrowableThread=new SyncThrowableThread<>(new Callable<Void>(){
    @Override public Void call() throws Exception {
      _assertHits(fieldValue,1);
      return null;
    }
  }
);
synchronized (_indexSearcherManager) {
    syncThrowableThread.start();
    while (syncThrowableThread.getState() != State.BLOCKED)     ;
    _assertHits(fieldValue,1);
  }
  syncThrowableThread.sync();
  _drainRefs(1);
  IndexReaderAdvice.block();
  FutureTask<IndexSearcher> futureTask1=new FutureTask<IndexSearcher>(new Callable<IndexSearcher>(){
    @Override public IndexSearcher call() throws Exception {
      return _indexSearcherManager.acquire();
    }
  }
);
  Thread thread=new Thread(futureTask1,"Concurrent Reopen 1");
  thread.start();
  IndexReaderAdvice.waitUntilBlock(1);
  _addDocument(fieldValue);
  _indexSearcherManager.invalidate();
  FutureTask<IndexSearcher> futureTask2=new FutureTask<IndexSearcher>(new Callable<IndexSearcher>(){
    @Override public IndexSearcher call() throws Exception {
      return _indexSearcherManager.acquire();
    }
  }
);
  thread=new Thread(futureTask2,"Concurrent Reopen 2");
  thread.start();
  IndexReaderAdvice.waitUntilBlock(2);
  IndexReaderAdvice.unblock(2);
  Assert.assertSame(futureTask1.get(),futureTask2.get());
  Assert.assertNotSame(indexSearcher,futureTask1.get());
  _drainRefs(0);
  try {
    _indexSearcherManager.acquire();
    Assert.fail();
  }
 catch (  IllegalStateException ise) {
    Assert.assertEquals("Index reader was closed externally",ise.getMessage());
  }
}
