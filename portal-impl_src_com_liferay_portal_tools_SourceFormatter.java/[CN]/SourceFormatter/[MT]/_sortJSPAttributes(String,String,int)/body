{
  String s=line;
  int x=s.indexOf(StringPool.SPACE);
  if (x == -1) {
    return line;
  }
  s=s.substring(x + 1);
  String previousAttribute=null;
  String previousAttributeAndValue=null;
  boolean wrongOrder=false;
  for (x=0; ; ) {
    x=s.indexOf(StringPool.EQUAL);
    if ((x == -1) || (s.length() <= (x + 1))) {
      return line;
    }
    String attribute=s.substring(0,x);
    if (!_isJSPAttributName(attribute)) {
      return line;
    }
    if (Validator.isNotNull(previousAttribute) && (previousAttribute.compareTo(attribute) > 0)) {
      wrongOrder=true;
    }
    s=s.substring(x + 1);
    char delimeter=s.charAt(0);
    if ((delimeter != CharPool.APOSTROPHE) && (delimeter != CharPool.QUOTE)) {
      _sourceFormatterHelper.printError(fileName,"delimeter: " + fileName + " "+ lineCount);
      return line;
    }
    s=s.substring(1);
    int y=s.indexOf(delimeter);
    if ((y == -1) || (s.length() <= (y + 1))) {
      return line;
    }
    String value=s.substring(0,y);
    if ((delimeter == CharPool.APOSTROPHE) && !value.contains(StringPool.QUOTE)) {
      return StringUtil.replace(line,StringPool.APOSTROPHE + value + StringPool.APOSTROPHE,StringPool.QUOTE + value + StringPool.QUOTE);
    }
    if (value.contains("<%") && !value.contains("%>")) {
      int z=s.indexOf("%>");
      if (z == -1) {
        return line;
      }
      y=s.substring(z).indexOf(delimeter);
      value=s.substring(0,y + z);
    }
    StringBundler sb=new StringBundler(5);
    sb.append(attribute);
    sb.append(StringPool.EQUAL);
    sb.append(delimeter);
    sb.append(value);
    sb.append(delimeter);
    String currentAttributeAndValue=sb.toString();
    if (wrongOrder) {
      if (line.contains(currentAttributeAndValue) && line.contains(previousAttributeAndValue)) {
        line=StringUtil.replaceFirst(line,previousAttributeAndValue,currentAttributeAndValue);
        line=StringUtil.replaceLast(line,currentAttributeAndValue,previousAttributeAndValue);
      }
      return line;
    }
    s=s.substring(y + 1);
    s=StringUtil.trimLeading(s);
    previousAttribute=attribute;
    previousAttributeAndValue=currentAttributeAndValue;
  }
}
