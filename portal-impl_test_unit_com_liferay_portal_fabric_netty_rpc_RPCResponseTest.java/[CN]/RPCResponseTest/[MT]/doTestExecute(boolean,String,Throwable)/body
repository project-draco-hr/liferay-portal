{
  RPCResponse<String> rpcResponse=new RPCResponse<String>(_id,cancelled,result,throwable);
  CaptureHandler captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.SEVERE);
  try {
    rpcResponse.execute(_embeddedChannel);
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    Assert.assertEquals(1,logRecords.size());
    LogRecord logRecord=logRecords.get(0);
    if (cancelled) {
      Assert.assertEquals("Unable to place cancellation because no future exists " + "with ID " + _id,logRecord.getMessage());
    }
 else     if (throwable != null) {
      Assert.assertEquals("Unable to place exception because no future exists with " + "ID " + _id,logRecord.getMessage());
      Assert.assertSame(throwable,logRecord.getThrown());
    }
 else {
      Assert.assertEquals("Unable to place result " + result + " because no future exists with ID "+ _id,logRecord.getMessage());
    }
  }
  finally {
    captureHandler.close();
  }
  captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.FINEST);
  try {
    AsyncBroker<Long,Serializable> asyncBroker=NettyChannelAttributes.getAsyncBroker(_embeddedChannel);
    NoticeableFuture<Serializable> noticeableFuture=asyncBroker.post(_id);
    rpcResponse.execute(_embeddedChannel);
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    if (!cancelled) {
      Assert.assertTrue(logRecords.isEmpty());
      return;
    }
    Assert.assertTrue(noticeableFuture.isCancelled());
    Assert.assertEquals(1,logRecords.size());
    LogRecord logRecord=logRecords.remove(0);
    Assert.assertEquals("Cancelled future with ID " + _id,logRecord.getMessage());
    DefaultNoticeableFuture<Serializable> defaultNoticeableFuture=new DefaultNoticeableFuture<Serializable>();
    defaultNoticeableFuture.cancel(true);
    ConcurrentMap<Long,DefaultNoticeableFuture<Serializable>> defaultNoticeableFutures=ReflectionTestUtil.getFieldValue(asyncBroker,"_defaultNoticeableFutures");
    defaultNoticeableFutures.put(_id,defaultNoticeableFuture);
    rpcResponse.execute(_embeddedChannel);
    Assert.assertEquals(1,logRecords.size());
    logRecord=logRecords.remove(0);
    Assert.assertEquals("Unable to cancel future with ID " + _id + " because it is already completed",logRecord.getMessage());
  }
  finally {
    captureHandler.close();
  }
  captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.OFF);
  try {
    AsyncBroker<Long,Serializable> asyncBroker=NettyChannelAttributes.getAsyncBroker(_embeddedChannel);
    NoticeableFuture<Serializable> noticeableFuture=asyncBroker.post(_id);
    rpcResponse.execute(_embeddedChannel);
    Assert.assertTrue(noticeableFuture.isCancelled());
    DefaultNoticeableFuture<Serializable> defaultNoticeableFuture=new DefaultNoticeableFuture<Serializable>();
    defaultNoticeableFuture.cancel(true);
    ConcurrentMap<Long,DefaultNoticeableFuture<Serializable>> defaultNoticeableFutures=ReflectionTestUtil.getFieldValue(asyncBroker,"_defaultNoticeableFutures");
    defaultNoticeableFutures.put(_id,defaultNoticeableFuture);
    rpcResponse.execute(_embeddedChannel);
  }
  finally {
    captureHandler.close();
  }
}
