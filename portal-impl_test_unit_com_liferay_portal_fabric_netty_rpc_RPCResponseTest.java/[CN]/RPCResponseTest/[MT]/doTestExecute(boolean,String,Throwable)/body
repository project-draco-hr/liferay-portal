{
  RPCResponse<String> rpcResponse=new RPCResponse<String>(_ID,cancelled,result,throwable);
  try (CaptureHandler captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.SEVERE)){
    rpcResponse.execute(_embeddedChannel);
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    Assert.assertEquals(1,logRecords.size());
    LogRecord logRecord=logRecords.get(0);
    if (cancelled) {
      Assert.assertEquals("Unable to place cancellation because no future exists " + "with ID " + _ID,logRecord.getMessage());
    }
 else     if (throwable != null) {
      Assert.assertEquals("Unable to place exception because no future exists with " + "ID " + _ID,logRecord.getMessage());
      Assert.assertSame(throwable,logRecord.getThrown());
    }
 else {
      Assert.assertEquals("Unable to place result " + result + " because no future exists with ID "+ _ID,logRecord.getMessage());
    }
  }
   try (CaptureHandler captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.FINEST)){
    AsyncBroker<Long,Serializable> asyncBroker=NettyChannelAttributes.getAsyncBroker(_embeddedChannel);
    NoticeableFuture<Serializable> noticeableFuture=asyncBroker.post(_ID);
    rpcResponse.execute(_embeddedChannel);
    List<LogRecord> logRecords=captureHandler.getLogRecords();
    if (!cancelled) {
      Assert.assertTrue(logRecords.isEmpty());
      return;
    }
    Assert.assertTrue(noticeableFuture.isCancelled());
    Assert.assertEquals(1,logRecords.size());
    LogRecord logRecord=logRecords.remove(0);
    Assert.assertEquals("Cancelled future with ID " + _ID,logRecord.getMessage());
    DefaultNoticeableFuture<Serializable> defaultNoticeableFuture=new DefaultNoticeableFuture<Serializable>();
    defaultNoticeableFuture.cancel(true);
    ConcurrentMap<Long,DefaultNoticeableFuture<Serializable>> defaultNoticeableFutures=ReflectionTestUtil.getFieldValue(asyncBroker,"_defaultNoticeableFutures");
    defaultNoticeableFutures.put(_ID,defaultNoticeableFuture);
    rpcResponse.execute(_embeddedChannel);
    Assert.assertEquals(1,logRecords.size());
    logRecord=logRecords.remove(0);
    Assert.assertEquals("Unable to cancel future with ID " + _ID + " because it is already completed",logRecord.getMessage());
  }
   try (CaptureHandler captureHandler=JDKLoggerTestUtil.configureJDKLogger(RPCResponse.class.getName(),Level.OFF)){
    AsyncBroker<Long,Serializable> asyncBroker=NettyChannelAttributes.getAsyncBroker(_embeddedChannel);
    NoticeableFuture<Serializable> noticeableFuture=asyncBroker.post(_ID);
    rpcResponse.execute(_embeddedChannel);
    Assert.assertTrue(noticeableFuture.isCancelled());
    DefaultNoticeableFuture<Serializable> defaultNoticeableFuture=new DefaultNoticeableFuture<Serializable>();
    defaultNoticeableFuture.cancel(true);
    ConcurrentMap<Long,DefaultNoticeableFuture<Serializable>> defaultNoticeableFutures=ReflectionTestUtil.getFieldValue(asyncBroker,"_defaultNoticeableFutures");
    defaultNoticeableFutures.put(_ID,defaultNoticeableFuture);
    rpcResponse.execute(_embeddedChannel);
  }
 }
