{
  List<LogRecord> logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.FINE);
  MockRegistrationReference mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  ChannelContext channelContext=new ChannelContext(null);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(false),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Broken read channel, unregister "));
  LogRecord logRecord=logRecords.get(0);
  Assert.assertTrue(logRecord.getThrown() instanceof IOException);
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.INFO);
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext=new ChannelContext(null);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(true),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Broken read channel, unregister "));
  logRecord=logRecords.get(0);
  Assert.assertNull(logRecord.getThrown());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext=new ChannelContext(null);
  channelContext.setReadingDatagram(Datagram.createReceiveDatagram());
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(false),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertTrue(logRecords.isEmpty());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  Pipe pipe=Pipe.open();
  SourceChannel sourceChannel=pipe.source();
  final SinkChannel sinkChannel=pipe.sink();
  Datagram requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.writeTo(sinkChannel);
  final ByteBuffer byteBuffer=ByteBuffer.allocate(_data.length + 14);
  while (byteBuffer.hasRemaining()) {
    sourceChannel.read(byteBuffer);
  }
  sourceChannel.configureBlocking(false);
  sinkChannel.configureBlocking(false);
  Thread slowWritingThread=new Thread(){
    @Override public void run(){
      try {
        for (        byte b : byteBuffer.array()) {
          sinkChannel.write(ByteBuffer.wrap(new byte[]{b}));
          Thread.sleep(1);
        }
      }
 catch (      Exception e) {
        Assert.fail(e.getMessage());
      }
    }
  }
;
  slowWritingThread.start();
  channelContext=new ChannelContext(null);
  Datagram receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  while (receiveDatagram == channelContext.getReadingDatagram()) {
    _mockIntraBand.handleReading(sourceChannel,channelContext);
  }
  slowWritingThread.join();
  Assert.assertEquals(_type,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  String message=logRecord.getMessage();
  Assert.assertTrue(message.startsWith("Dropped ownerless request "));
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertTrue(logRecords.isEmpty());
  long sequenceId=100;
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  Datagram ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckResponse());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Dropped ownerless ACK response "));
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckResponse());
  Assert.assertTrue(logRecords.isEmpty());
  RecordCompletionHandler<Object> recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  requestDatagram.setSequenceId(sequenceId);
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  recordCompletionHandler.waitUntilDelivered();
  Assert.assertTrue(receiveDatagram.isAckResponse());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  Datagram responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Dropped ownerless response "));
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertTrue(logRecords.isEmpty());
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.completionTypes=BaseIntraBand.REPLIED_ENUM_SET;
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  requestDatagram.setSequenceId(sequenceId);
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  recordCompletionHandler.waitUntilReplied();
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.completionTypes=EnumSet.noneOf(CompletionType.class);
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  requestDatagram.setSequenceId(sequenceId);
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Dropped unconcerned response "));
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.completionTypes=EnumSet.noneOf(CompletionType.class);
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  requestDatagram.setSequenceId(sequenceId);
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertTrue(logRecords.isEmpty());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setAckRequest(true);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.writeTo(sinkChannel);
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext=new ChannelContext(null);
  channelContext.setRegistrationReference(mockRegistrationReference);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckRequest());
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Dropped ownerless request "));
  Assert.assertSame(mockRegistrationReference,_mockIntraBand.getRegistrationReference());
  Datagram datagram=_mockIntraBand.getDatagram();
  Assert.assertEquals(sequenceId,datagram.getSequenceId());
  Assert.assertTrue(datagram.isAckResponse());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.SEVERE);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  RecordDatagramReceiveHandler recordDatagramReceiveHandler=new RecordDatagramReceiveHandler();
  _mockIntraBand.registerDatagramReceiveHandler(_type,recordDatagramReceiveHandler);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  requestDatagram.setAckRequest(true);
  requestDatagram.setSequenceId(sequenceId);
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  requestDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  Assert.assertArrayEquals(_data,receiveDatagram.getData());
  Datagram recordDatagram=recordDatagramReceiveHandler.getReceiveDatagram();
  Assert.assertSame(receiveDatagram,recordDatagram);
  Assert.assertEquals(_type,recordDatagram.getType());
  Assert.assertArrayEquals(_data,recordDatagram.getData());
  Assert.assertEquals(1,logRecords.size());
  Assert.assertTrue(hasLogMessage(logRecords,"Unable to dispatch"));
  logRecord=logRecords.get(0);
  Assert.assertTrue(logRecord.getThrown() instanceof RuntimeException);
  sourceChannel.close();
  sinkChannel.close();
}
