{
  List<LogRecord> logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.FINE);
  ChannelContext channelContext=new ChannelContext(null);
  MockRegistrationReference mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(false),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertEquals(1,logRecords.size());
  LogRecord logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Broken read channel, unregister ");
  Assert.assertTrue(logRecord.getThrown() instanceof IOException);
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.INFO);
  channelContext=new ChannelContext(null);
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(true),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Broken read channel, unregister ");
  Assert.assertNull(logRecord.getThrown());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  channelContext=new ChannelContext(null);
  channelContext.setReadingDatagram(Datagram.createReceiveDatagram());
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(new MockScatteringByteChannel(false),channelContext);
  Assert.assertFalse(mockRegistrationReference.isValid());
  Assert.assertTrue(logRecords.isEmpty());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  Pipe pipe=Pipe.open();
  SourceChannel sourceChannel=pipe.source();
  final SinkChannel sinkChannel=pipe.sink();
  Datagram requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.writeTo(sinkChannel);
  final ByteBuffer byteBuffer=ByteBuffer.allocate(_data.length + 14);
  while (byteBuffer.hasRemaining()) {
    sourceChannel.read(byteBuffer);
  }
  sourceChannel.configureBlocking(false);
  sinkChannel.configureBlocking(false);
  Thread slowWritingThread=new Thread(){
    @Override public void run(){
      try {
        for (        byte b : byteBuffer.array()) {
          sinkChannel.write(ByteBuffer.wrap(new byte[]{b}));
          Thread.sleep(1);
        }
      }
 catch (      Exception e) {
        Assert.fail(e.getMessage());
      }
    }
  }
;
  slowWritingThread.start();
  channelContext=new ChannelContext(null);
  Datagram receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  while (receiveDatagram == channelContext.getReadingDatagram()) {
    _mockIntraBand.handleReading(sourceChannel,channelContext);
  }
  slowWritingThread.join();
  Assert.assertEquals(_type,receiveDatagram.getType());
  ByteBuffer dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Dropped ownerless request ");
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertTrue(logRecords.isEmpty());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  long sequenceId=100;
  Datagram ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckResponse());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Dropped ownerless ACK response ");
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckResponse());
  Assert.assertTrue(logRecords.isEmpty());
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setSequenceId(sequenceId);
  RecordCompletionHandler<Object> recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  ackResponseDatagram=Datagram.createACKResponseDatagram(sequenceId);
  ackResponseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  recordCompletionHandler.waitUntilDelivered();
  Assert.assertTrue(receiveDatagram.isAckResponse());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  Datagram responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Dropped ownerless response ");
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertTrue(logRecords.isEmpty());
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.completionTypes=BaseIntraBand.REPLIED_ENUM_SET;
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  recordCompletionHandler.waitUntilReplied();
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.completionTypes=EnumSet.noneOf(CompletionType.class);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Dropped unconcerned response ");
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.OFF);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.completionTypes=EnumSet.noneOf(CompletionType.class);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  responseDatagram=Datagram.createResponseDatagram(requestDatagram,_data);
  responseDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isResponse());
  Assert.assertEquals(0,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertTrue(logRecords.isEmpty());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.WARNING);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  requestDatagram.setAckRequest(true);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.writeTo(sinkChannel);
  channelContext=new ChannelContext(null);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  mockRegistrationReference=new MockRegistrationReference(_mockIntraBand);
  channelContext.setRegistrationReference(mockRegistrationReference);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isAckRequest());
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Dropped ownerless request ");
  Assert.assertSame(mockRegistrationReference,_mockIntraBand.getRegistrationReference());
  Datagram datagram=_mockIntraBand.getDatagram();
  Assert.assertEquals(sequenceId,datagram.getSequenceId());
  Assert.assertTrue(datagram.isAckResponse());
  logRecords=JDKLoggerTestUtil.configureJDKLogger(BaseIntraBand.class.getName(),Level.SEVERE);
  RecordDatagramReceiveHandler recordDatagramReceiveHandler=new RecordDatagramReceiveHandler();
  _mockIntraBand.registerDatagramReceiveHandler(_type,recordDatagramReceiveHandler);
  requestDatagram=Datagram.createRequestDatagram(_type,_data);
  recordCompletionHandler=new RecordCompletionHandler<Object>();
  requestDatagram.setAckRequest(true);
  requestDatagram.setSequenceId(sequenceId);
  requestDatagram.completionHandler=recordCompletionHandler;
  requestDatagram.timeout=10000;
  _mockIntraBand.addResponseWaitingDatagram(requestDatagram);
  requestDatagram.writeTo(sinkChannel);
  receiveDatagram=Datagram.createReceiveDatagram();
  channelContext.setReadingDatagram(receiveDatagram);
  _mockIntraBand.handleReading(sourceChannel,channelContext);
  Assert.assertTrue(receiveDatagram.isRequest());
  Assert.assertEquals(_type,receiveDatagram.getType());
  dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Datagram recordDatagram=recordDatagramReceiveHandler.getReceiveDatagram();
  Assert.assertSame(receiveDatagram,recordDatagram);
  Assert.assertEquals(_type,recordDatagram.getType());
  dataByteBuffer=recordDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  Assert.assertEquals(1,logRecords.size());
  logRecord=logRecords.get(0);
  _assertMessageStartWith(logRecord,"Unable to dispatch");
  Assert.assertTrue(logRecord.getThrown() instanceof RuntimeException);
  sourceChannel.close();
  sinkChannel.close();
}
