{
  Annotation annotation=ServiceMethodAnnotationCache.get(methodInvocation,_annotationClass,_nullAnnotation);
  if (annotation != null) {
    return (T)annotation;
  }
  Object thisObject=methodInvocation.getThis();
  Class<?> targetClass=thisObject.getClass();
  Method method=methodInvocation.getMethod();
  Method targetMethod=null;
  try {
    targetMethod=targetClass.getDeclaredMethod(method.getName(),method.getParameterTypes());
  }
 catch (  Throwable t) {
  }
  Annotation[] annotations=null;
  if (targetMethod != null) {
    annotations=targetMethod.getAnnotations();
  }
  if ((annotations == null) || (annotations.length == 0)) {
    annotations=method.getAnnotations();
  }
  if ((annotations != null) && (annotations.length > 0)) {
    List<Annotation> annotationsList=new ArrayList<Annotation>(annotations.length);
    for (    Annotation curAnnotation : annotations) {
      if (_annotationChainableMethodAdvices.containsKey(curAnnotation.annotationType())) {
        annotationsList.add(curAnnotation);
      }
    }
    annotations=annotationsList.toArray(new Annotation[annotationsList.size()]);
  }
  ServiceMethodAnnotationCache.put(methodInvocation,annotations);
  Set<Class<? extends Annotation>> annotationClasses=new HashSet<Class<? extends Annotation>>();
  annotation=_nullAnnotation;
  for (  Annotation curAnnotation : annotations) {
    Class<? extends Annotation> annotationClass=curAnnotation.annotationType();
    if (annotationClass == _annotationClass) {
      annotation=curAnnotation;
    }
    annotationClasses.add(annotationClass);
  }
  for (  Map.Entry<Class<? extends Annotation>,AnnotationChainableMethodAdvice<?>> entry : _annotationChainableMethodAdvices.entrySet()) {
    Class<? extends Annotation> annotationClass=entry.getKey();
    AnnotationChainableMethodAdvice<?> annotationChainableMethodAdvice=entry.getValue();
    if ((!annotationClasses.contains(annotationClass)) && (annotationChainableMethodAdvice != null)) {
      ServiceBeanAopProxy.removeMethodInterceptor(methodInvocation,annotationChainableMethodAdvice);
    }
  }
  return (T)annotation;
}
