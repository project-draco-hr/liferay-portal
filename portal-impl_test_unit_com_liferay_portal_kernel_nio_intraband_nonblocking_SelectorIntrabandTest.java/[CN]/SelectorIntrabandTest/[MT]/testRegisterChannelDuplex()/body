{
  try {
    _selectorIntraband.registerChannel(null);
    Assert.fail();
  }
 catch (  NullPointerException npe) {
    Assert.assertEquals("Channel is null",npe.getMessage());
  }
  try {
    _selectorIntraband.registerChannel(IntrabandTestUtil.<Channel>createProxy(Channel.class));
    Assert.fail();
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Channel is not of type GatheringByteChannel",iae.getMessage());
  }
  try {
    _selectorIntraband.registerChannel(IntrabandTestUtil.<Channel>createProxy(GatheringByteChannel.class));
    Assert.fail();
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Channel is not of type ScatteringByteChannel",iae.getMessage());
  }
  try {
    _selectorIntraband.registerChannel(IntrabandTestUtil.<Channel>createProxy(ScatteringByteChannel.class,GatheringByteChannel.class));
    Assert.fail();
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Channel is not of type SelectableChannel",iae.getMessage());
  }
  try {
    _selectorIntraband.registerChannel(new MockDuplexSelectableChannel(false,true));
    Assert.fail();
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Channel is not valid for reading",iae.getMessage());
  }
  try {
    _selectorIntraband.registerChannel(new MockDuplexSelectableChannel(true,false));
    Assert.fail();
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Channel is not valid for writing",iae.getMessage());
  }
  SocketChannel[] peerSocketChannels=IntrabandTestUtil.createSocketChannelPeers();
  try {
    SocketChannel socketChannel=peerSocketChannels[0];
    final Thread mainThread=Thread.currentThread();
    Thread wakeUpThread=new Thread(new WakeUpRunnable(_selectorIntraband));
    Thread interruptThread=new Thread(){
      @Override public void run(){
        while (mainThread.getState() != Thread.State.WAITING)         ;
        mainThread.interrupt();
      }
    }
;
    wakeUpThread.start();
    Selector selector=_selectorIntraband.selector;
synchronized (selector) {
      wakeUpThread.interrupt();
      wakeUpThread.join();
      interruptThread.start();
      try {
        _selectorIntraband.registerChannel(socketChannel);
        Assert.fail();
      }
 catch (      IOException ioe) {
        Throwable cause=ioe.getCause();
        Assert.assertTrue(cause instanceof InterruptedException);
      }
      interruptThread.join();
    }
    _selectorIntraband.close();
    _selectorIntraband=new SelectorIntraband(_DEFAULT_TIMEOUT);
    SelectionKeyRegistrationReference selectionKeyRegistrationReference=(SelectionKeyRegistrationReference)_selectorIntraband.registerChannel(socketChannel);
    Assert.assertNotNull(selectionKeyRegistrationReference);
    Assert.assertSame(selectionKeyRegistrationReference.readSelectionKey,selectionKeyRegistrationReference.writeSelectionKey);
    SelectionKey selectionKey=selectionKeyRegistrationReference.readSelectionKey;
    Assert.assertTrue(selectionKey.isValid());
    Assert.assertEquals(SelectionKey.OP_READ,selectionKey.interestOps());
    Assert.assertNotNull(selectionKey.attachment());
    selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    selector=_selectorIntraband.selector;
    selector.wakeup();
    while (selectionKey.interestOps() != SelectionKey.OP_READ)     ;
    wakeUpThread=new Thread(new WakeUpRunnable(_selectorIntraband));
    wakeUpThread.start();
synchronized (selector) {
      wakeUpThread.interrupt();
      wakeUpThread.join();
      selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
      SocketChannel peerSocketChannel=peerSocketChannels[1];
      peerSocketChannel.write(ByteBuffer.allocate(1));
      Socket socket=peerSocketChannel.socket();
      socket.shutdownOutput();
    }
    while (selectionKey.isValid())     ;
    _selectorIntraband.close();
    try {
      _selectorIntraband.registerChannel(socketChannel);
      Assert.fail();
    }
 catch (    ClosedIntrabandException cie) {
    }
  }
  finally {
    peerSocketChannels[0].close();
    peerSocketChannels[1].close();
  }
}
