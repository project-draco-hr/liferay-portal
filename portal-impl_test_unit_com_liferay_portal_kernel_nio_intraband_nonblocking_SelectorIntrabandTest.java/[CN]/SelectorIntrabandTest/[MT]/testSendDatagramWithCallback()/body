{
  Pipe readPipe=Pipe.open();
  Pipe writePipe=Pipe.open();
  GatheringByteChannel gatheringByteChannel=writePipe.sink();
  ScatteringByteChannel scatteringByteChannel=readPipe.source();
  RegistrationReference registrationReference=_selectorIntraband.registerChannel(writePipe.source(),readPipe.sink());
  Object attachment=new Object();
  RecordCompletionHandler<Object> recordCompletionHandler=new RecordCompletionHandler<Object>();
  _selectorIntraband.sendDatagram(registrationReference,Datagram.createRequestDatagram(_TYPE,_data),attachment,EnumSet.of(CompletionType.SUBMITTED),recordCompletionHandler);
  Datagram receiveDatagram=IntrabandTestUtil.readDatagramFully(scatteringByteChannel);
  recordCompletionHandler.waitUntilSubmitted();
  Assert.assertSame(attachment,recordCompletionHandler.getAttachment());
  Assert.assertEquals(_TYPE,receiveDatagram.getType());
  ByteBuffer dataByteBuffer=receiveDatagram.getDataByteBuffer();
  Assert.assertArrayEquals(_data,dataByteBuffer.array());
  CaptureHandler captureHandler1=JDKLoggerTestUtil.configureJDKLogger(BaseIntraband.class.getName(),Level.WARNING);
  try {
    List<LogRecord> logRecords=captureHandler1.getLogRecords();
    recordCompletionHandler=new RecordCompletionHandler<Object>();
    _selectorIntraband.sendDatagram(registrationReference,Datagram.createRequestDatagram(_TYPE,_data),attachment,EnumSet.of(CompletionType.DELIVERED),recordCompletionHandler,10,TimeUnit.MILLISECONDS);
    Selector selector=_selectorIntraband.selector;
    recordCompletionHandler.waitUntilTimeouted(selector);
    Assert.assertSame(attachment,recordCompletionHandler.getAttachment());
    Assert.assertEquals(1,logRecords.size());
    IntrabandTestUtil.assertMessageStartWith(logRecords.get(0),"Removed timeout response waiting datagram");
    logRecords=captureHandler1.resetLogLevel(Level.OFF);
    recordCompletionHandler=new RecordCompletionHandler<Object>();
    _selectorIntraband.sendDatagram(registrationReference,Datagram.createRequestDatagram(_TYPE,_data),attachment,EnumSet.of(CompletionType.DELIVERED),recordCompletionHandler,10,TimeUnit.MILLISECONDS);
    recordCompletionHandler.waitUntilTimeouted(selector);
    Assert.assertSame(attachment,recordCompletionHandler.getAttachment());
    Assert.assertTrue(logRecords.isEmpty());
  }
  finally {
    captureHandler1.close();
  }
  captureHandler1=JDKLoggerTestUtil.configureJDKLogger(SelectorIntraband.class.getName(),Level.SEVERE);
  try {
    List<LogRecord> logRecords1=captureHandler1.getLogRecords();
    recordCompletionHandler=new RecordCompletionHandler<Object>(){
      @Override public void timedOut(      Object attachment){
        super.timedOut(attachment);
        throw new NullPointerException();
      }
    }
;
    Jdk14LogImplAdvice.reset();
    Selector selector=_selectorIntraband.selector;
    Datagram datagram=Datagram.createRequestDatagram(_TYPE,_data);
    try {
      _selectorIntraband.sendDatagram(registrationReference,datagram,attachment,EnumSet.of(CompletionType.DELIVERED),recordCompletionHandler,10,TimeUnit.MILLISECONDS);
    }
  finally {
      CaptureHandler captureHandler2=JDKLoggerTestUtil.configureJDKLogger(BaseIntraband.class.getName(),Level.WARNING);
      try {
        recordCompletionHandler.waitUntilTimeouted(selector);
        List<LogRecord> logRecords2=captureHandler2.getLogRecords();
        Assert.assertEquals(1,logRecords2.size());
        LogRecord logRecord=logRecords2.get(0);
        Assert.assertEquals("Removed timeout response waiting datagram " + datagram,logRecord.getMessage());
      }
  finally {
        captureHandler2.close();
      }
      Jdk14LogImplAdvice.waitUntilErrorCalled();
    }
    Assert.assertFalse(selector.isOpen());
    Assert.assertEquals(1,logRecords1.size());
    IntrabandTestUtil.assertMessageStartWith(logRecords1.get(0),SelectorIntraband.class + ".threadFactory-1 exiting exceptionally");
    gatheringByteChannel.close();
    scatteringByteChannel.close();
  }
  finally {
    captureHandler1.close();
  }
}
