{
  String returnValue="Premature return value";
  ReturnWithoutExitProcessCallable returnWithoutExitProcessCallable=new ReturnWithoutExitProcessCallable(returnValue);
  ProcessExecutor processExecutor=new ProcessExecutor();
  _nullOutExecutorService();
  Future<String> future=processExecutor.execute(_classPath,returnWithoutExitProcessCallable);
  ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)_getExecutorService();
  Field workersField=ReflectionUtil.getDeclaredField(ThreadPoolExecutor.class,"workers");
  Set<?> workers=(Set<?>)workersField.get(threadPoolExecutor);
  assertEquals(1,workers.size());
  Object worker=workers.iterator().next();
  Field threadField=ReflectionUtil.getDeclaredField(worker.getClass(),"thread");
  Thread executorThread=(Thread)threadField.get(worker);
  Logger logger=_getLogger();
  if (OSDetector.isWindows()) {
    logger.log(Level.WARNING,"Can not do Thread.State checking on " + "Windows! Blindly waiting 10 seconds for blocking on" + "Process.waitFor(), on slow machine this may not be enough, "+ "which will cause this test to fail");
    Thread.sleep(10000);
  }
 else {
    while (executorThread.getState() != Thread.State.WAITING)     ;
  }
  Level oldLevel=logger.getLevel();
  logger.setLevel(Level.OFF);
  try {
    processExecutor.destroy();
    try {
      future.get();
      fail();
    }
 catch (    ExecutionException ee) {
      assertFalse(future.isCancelled());
      assertTrue(future.isDone());
      Throwable throwable=ee.getCause();
      assertTrue(throwable instanceof ProcessException);
      throwable=throwable.getCause();
      assertTrue(throwable instanceof InterruptedException);
    }
  }
  finally {
    logger.setLevel(oldLevel);
  }
}
