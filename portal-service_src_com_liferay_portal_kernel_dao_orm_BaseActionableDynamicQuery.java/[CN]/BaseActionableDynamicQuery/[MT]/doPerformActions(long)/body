{
  final DynamicQuery dynamicQuery=DynamicQueryFactoryUtil.forClass(_clazz,_classLoader);
  Property property=PropertyFactoryUtil.forName(_primaryKeyPropertyName);
  dynamicQuery.add(property.gt(previousPrimaryKey));
  dynamicQuery.setLimit(0,_interval);
  addDefaultCriteria(dynamicQuery);
  addCriteria(dynamicQuery);
  addOrderCriteria(dynamicQuery);
  Callable<Long> callable=new Callable<Long>(){
    @Override public Long call() throws Exception {
      List<Object> objects=(List<Object>)executeDynamicQuery(_dynamicQueryMethod,dynamicQuery);
      if (objects.isEmpty()) {
        return -1L;
      }
      List<Future<Void>> futures=new ArrayList<>(objects.size());
      for (      final Object object : objects) {
        if (_parallel) {
          futures.add(_threadPoolExecutor.submit(new Callable<Void>(){
            @Override public Void call() throws Exception {
              performAction(object);
              return null;
            }
          }
));
        }
 else {
          performAction(object);
        }
      }
      for (      Future<Void> future : futures) {
        future.get();
      }
      if (objects.size() < _interval) {
        return -1L;
      }
      BaseModel<?> baseModel=(BaseModel<?>)objects.get(objects.size() - 1);
      return (Long)baseModel.getPrimaryKeyObj();
    }
  }
;
  TransactionAttribute transactionAttribute=getTransactionAttribute();
  try {
    if (transactionAttribute == null) {
      return callable.call();
    }
 else {
      return TransactionInvokerUtil.invoke(transactionAttribute,callable);
    }
  }
 catch (  Throwable t) {
    if (t instanceof PortalException) {
      throw (PortalException)t;
    }
    if (t instanceof SystemException) {
      throw (SystemException)t;
    }
    throw new SystemException(t);
  }
 finally {
    indexInterval();
  }
}
