{
  _inputIContainer=IContainer.make();
  _outputIContainer=IContainer.make();
  openContainer(_inputIContainer,_inputURL,false);
  openContainer(_outputIContainer,_outputURL,true);
  int inputStreamsCount=_inputIContainer.getNumStreams();
  if (inputStreamsCount < 0) {
    throw new RuntimeException("Input URL does not have any streams");
  }
  IAudioResampler[] iAudioResamplers=new IAudioResampler[inputStreamsCount];
  IAudioSamples[] inputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IAudioSamples[] outputIAudioSamples=new IAudioSamples[inputStreamsCount];
  IStream[] outputIStreams=new IStream[inputStreamsCount];
  IStreamCoder[] inputIStreamCoders=new IStreamCoder[inputStreamsCount];
  IStreamCoder[] outputIStreamCoders=new IStreamCoder[inputStreamsCount];
  for (int i=0; i < inputStreamsCount; i++) {
    IStream inputIStream=_inputIContainer.getStream(i);
    IStreamCoder inputIStreamCoder=inputIStream.getStreamCoder();
    inputIStreamCoders[i]=inputIStreamCoder;
    ICodec.Type inputICodecType=inputIStreamCoder.getCodecType();
    if (inputICodecType == ICodec.Type.CODEC_TYPE_AUDIO) {
      prepareAudio(iAudioResamplers,inputIAudioSamples,outputIAudioSamples,inputIStreamCoder,outputIStreamCoders,_outputIContainer,outputIStreams,inputICodecType,_outputURL,i);
    }
    openStreamCoder(inputIStreamCoders[i]);
    openStreamCoder(outputIStreamCoders[i]);
  }
  if (_outputIContainer.writeHeader() < 0) {
    throw new RuntimeException("Unable to write container header");
  }
  IPacket inputIPacket=IPacket.make();
  IPacket outputIPacket=IPacket.make();
  int previousPacketSize=-1;
  _inputIContainer.readNextPacket(inputIPacket);
  while (_inputIContainer.readNextPacket(inputIPacket) == 0) {
    if (_log.isDebugEnabled()) {
      _log.debug("Current packet size " + inputIPacket.getSize());
    }
    int streamIndex=inputIPacket.getStreamIndex();
    IStreamCoder inputIStreamCoder=inputIStreamCoders[streamIndex];
    IStreamCoder outputIStreamCoder=outputIStreamCoders[streamIndex];
    if (outputIStreamCoder == null) {
      continue;
    }
    if (inputIStreamCoder.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO) {
      IStream iStream=_inputIContainer.getStream(streamIndex);
      long timeStampOffset=getStreamTimeStampOffset(iStream);
      decodeAudio(iAudioResamplers[streamIndex],inputIAudioSamples[streamIndex],outputIAudioSamples[streamIndex],inputIPacket,outputIPacket,inputIStreamCoder,outputIStreamCoder,_outputIContainer,inputIPacket.getSize(),previousPacketSize,streamIndex,timeStampOffset);
    }
    previousPacketSize=inputIPacket.getSize();
  }
  flush(outputIStreamCoders,_outputIContainer);
  if (_outputIContainer.writeTrailer() < 0) {
    throw new RuntimeException("Unable to write trailer to output file");
  }
  cleanUp(iAudioResamplers,null);
  cleanUp(inputIAudioSamples,outputIAudioSamples);
  cleanUp(inputIStreamCoders,outputIStreamCoders);
  cleanUp(inputIPacket,outputIPacket);
}
