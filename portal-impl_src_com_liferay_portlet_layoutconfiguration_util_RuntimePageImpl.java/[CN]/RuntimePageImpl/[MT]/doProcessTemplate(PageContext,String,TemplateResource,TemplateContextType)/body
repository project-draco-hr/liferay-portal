{
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
  TemplateProcessor processor=new TemplateProcessor(request,response,portletId);
  Template template=TemplateManagerUtil.getTemplate(TemplateManager.VELOCITY,templateResource,templateContextType);
  template.put("processor",processor);
  template.prepare(request);
  UnsyncStringWriter unsyncStringWriter=new UnsyncStringWriter();
  Object velocityTaglib=buildVelocityTaglib(request,new PipingServletResponse(response,unsyncStringWriter),pageContext);
  template.put("taglibLiferay",velocityTaglib);
  template.put("theme",velocityTaglib);
  try {
    template.processTemplate(unsyncStringWriter);
  }
 catch (  Exception e) {
    _log.error(e,e);
    throw e;
  }
  boolean portletParallelRender=GetterUtil.getBoolean(request.getAttribute(WebKeys.PORTLET_PARALLEL_RENDER));
  Lock lock=null;
  Map<String,StringBundler> contentsMap=new HashMap<String,StringBundler>();
  Map<Integer,List<PortletRenderer>> portletRenderersMap=processor.getPortletRenderers();
  for (  Map.Entry<Integer,List<PortletRenderer>> entry : portletRenderersMap.entrySet()) {
    if (_log.isDebugEnabled()) {
      _log.debug("Processing portlets with render weight " + entry.getKey());
    }
    List<PortletRenderer> portletRenderers=entry.getValue();
    if (portletParallelRender && (portletRenderers.size() > 1)) {
      StopWatch stopWatch=null;
      if (_log.isDebugEnabled()) {
        _log.debug("Start parallel rendering");
        stopWatch=new StopWatch();
        stopWatch.start();
      }
      if (lock == null) {
        lock=new ReentrantLock();
      }
      request.setAttribute(WebKeys.PARALLEL_RENDERING_MERGE_LOCK,lock);
      ObjectValuePair<HttpServletRequest,Closeable> objectValuePair=ThreadLocalFacadeServletRequestWrapperUtil.inject(request);
      try {
        parallelyRenderPortlets(objectValuePair.getKey(),response,processor,contentsMap,portletRenderers);
      }
  finally {
        Closeable closeable=objectValuePair.getValue();
        closeable.close();
      }
      request.removeAttribute(WebKeys.PARALLEL_RENDERING_MERGE_LOCK);
      if (_log.isDebugEnabled()) {
        _log.debug("Finished parallel rendering in " + stopWatch.getTime() + " ms");
      }
    }
 else {
      StopWatch stopWatch=null;
      if (_log.isDebugEnabled()) {
        _log.debug("Start serial rendering");
        stopWatch=new StopWatch();
        stopWatch.start();
      }
      for (      PortletRenderer portletRenderer : portletRenderers) {
        Portlet portlet=portletRenderer.getPortlet();
        contentsMap.put(portlet.getPortletId(),portletRenderer.render(request,response));
        if (_log.isDebugEnabled()) {
          _log.debug("Serially rendered portlet " + portlet.getPortletId() + " in "+ stopWatch.getTime()+ " ms");
        }
      }
      if (_log.isDebugEnabled()) {
        _log.debug("Finished serial rendering in " + stopWatch.getTime() + " ms");
      }
    }
  }
  if (portletParallelRender && (_waitTime == Integer.MAX_VALUE)) {
    _waitTime=PropsValues.LAYOUT_PARALLEL_RENDER_TIMEOUT;
  }
  StringBundler sb=StringUtil.replaceWithStringBundler(unsyncStringWriter.toString(),"[$TEMPLATE_PORTLET_","$]",contentsMap);
  sb.writeTo(pageContext.getOut());
}
