{
  JavaClass javaClass=_getJavaClass(_outputPath + "/service/impl/" + entity.getName()+ (sessionType != _REMOTE ? "Local" : "")+ "ServiceImpl.java");
  JavaMethod[] methods=javaClass.getMethods();
  if (sessionType == _LOCAL) {
    if (javaClass.getSuperClass().getValue().endsWith(entity.getName() + "LocalServiceBaseImpl")) {
      JavaClass parentJavaClass=_getJavaClass(_outputPath + "/service/base/" + entity.getName()+ "LocalServiceBaseImpl.java");
      JavaMethod[] parentMethods=parentJavaClass.getMethods();
      JavaMethod[] allMethods=new JavaMethod[parentMethods.length + methods.length];
      ArrayUtil.combine(parentMethods,methods,allMethods);
      methods=allMethods;
    }
  }
  StringMaker sm=new StringMaker();
  sm.append("package " + _packagePath + ".service;");
  sm.append("public interface " + entity.getName() + _getSessionTypeName(sessionType)+ "Service {");
  for (int i=0; i < methods.length; i++) {
    JavaMethod javaMethod=methods[i];
    String methodName=javaMethod.getName();
    if (!javaMethod.isConstructor() && javaMethod.isPublic() && _isCustomMethod(javaMethod)) {
      sm.append("public " + javaMethod.getReturns().getValue() + _getDimensions(javaMethod.getReturns())+ " "+ methodName+ "(");
      JavaParameter[] parameters=javaMethod.getParameters();
      for (int j=0; j < parameters.length; j++) {
        JavaParameter javaParameter=parameters[j];
        sm.append(javaParameter.getType().getValue() + _getDimensions(javaParameter.getType()) + " "+ javaParameter.getName());
        if ((j + 1) != parameters.length) {
          sm.append(", ");
        }
      }
      sm.append(")");
      Type[] thrownExceptions=javaMethod.getExceptions();
      Set newExceptions=new LinkedHashSet();
      for (int j=0; j < thrownExceptions.length; j++) {
        Type thrownException=thrownExceptions[j];
        newExceptions.add(thrownException.getValue());
      }
      if (sessionType != _LOCAL) {
        newExceptions.add("java.rmi.RemoteException");
      }
      if (newExceptions.size() > 0) {
        sm.append(" throws ");
        Iterator itr=newExceptions.iterator();
        while (itr.hasNext()) {
          sm.append(itr.next());
          if (itr.hasNext()) {
            sm.append(", ");
          }
        }
      }
      sm.append(";");
    }
  }
  sm.append("}");
  File ejbFile=new File(_serviceOutputPath + "/service/" + entity.getName()+ _getSessionTypeName(sessionType)+ "Service.java");
  Map jalopySettings=new HashMap();
  String serviceComments=null;
  if (sessionType == _REMOTE) {
    serviceComments="This is a remote service. Methods of this service are expected to have security checks based on the propagated JAAS credentials because this service can be accessed remotely.";
  }
 else {
    serviceComments="This is a local service. Methods of this service will not have security checks based on the propagated JAAS credentials because this service can only be accessed from within the same VM.";
  }
  String[] classComments={_DEFAULT_CLASS_COMMENTS,"This interface defines the service. The default implementation is <code>" + _packagePath + ".service.impl."+ entity.getName()+ _getSessionTypeName(sessionType)+ "ServiceImpl</code>. Modify methods in that class and rerun ServiceBuilder to populate this class and all other generated classes.",serviceComments};
  String[] see={_packagePath + ".service." + entity.getName()+ "ServiceFactory",_packagePath + ".service." + entity.getName()+ "ServiceUtil"};
  jalopySettings.put("classComments",classComments);
  jalopySettings.put("see",see);
  writeFile(ejbFile,sm.toString(),jalopySettings);
}
