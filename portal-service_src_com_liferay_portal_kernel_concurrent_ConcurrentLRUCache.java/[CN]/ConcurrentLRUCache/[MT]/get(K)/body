{
  Entry<K,V> matchEntry=null;
  boolean requiresMove=false;
  _readLock.lock();
  try {
    matchEntry=_lastEntry._previousEntry;
    while (matchEntry != _headEntry) {
      if (matchEntry._key.equals(key)) {
        if (matchEntry._nextEntry != _lastEntry) {
          requiresMove=true;
        }
        _hitCount.getAndIncrement();
        return matchEntry._value;
      }
      matchEntry=matchEntry._previousEntry;
    }
  }
  finally {
    _readLock.unlock();
    if (requiresMove) {
      _writeLock.lock();
      try {
        if (matchEntry._key != null) {
          _detachEntry(matchEntry);
          _insertEntryBefore(_lastEntry,matchEntry);
        }
      }
  finally {
        _writeLock.unlock();
      }
    }
  }
  _missCount.getAndIncrement();
  return null;
}
