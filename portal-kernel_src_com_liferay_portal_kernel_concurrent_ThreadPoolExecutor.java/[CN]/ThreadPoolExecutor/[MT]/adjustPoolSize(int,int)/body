{
  if ((newCorePoolSize < 0) || (newMaxPoolSize <= 0) || (newMaxPoolSize < newCorePoolSize)) {
    throw new IllegalArgumentException();
  }
  _mainLock.lock();
  try {
    int surplusCoreThreads=_corePoolSize - newCorePoolSize;
    int surplusMaxPoolSize=_maxPoolSize - newMaxPoolSize;
    _corePoolSize=newCorePoolSize;
    _maxPoolSize=newMaxPoolSize;
    if (((surplusCoreThreads > 0) && (_poolSize > _corePoolSize)) || ((surplusMaxPoolSize > 0) && (_poolSize > _maxPoolSize))) {
      int interruptCount=Math.max(surplusCoreThreads,surplusMaxPoolSize);
      for (      WorkerTask workerTask : _workerTasks) {
        if (interruptCount > 0) {
          if (workerTask._interruptIfWaiting()) {
            interruptCount--;
          }
        }
 else {
          break;
        }
      }
    }
 else {
      Runnable runnable=null;
      while ((surplusCoreThreads++ < 0) && (_poolSize < _corePoolSize) && ((runnable=_taskQueue.poll()) != null)) {
        _doAddWorkerThread(runnable);
      }
    }
  }
  finally {
    _mainLock.unlock();
  }
}
