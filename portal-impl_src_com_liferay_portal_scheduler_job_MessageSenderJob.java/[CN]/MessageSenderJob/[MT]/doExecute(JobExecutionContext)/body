{
  JobDetail jobDetail=jobExecutionContext.getJobDetail();
  JobDataMap jobDataMap=jobDetail.getJobDataMap();
  String destinationName=jobDataMap.getString(SchedulerEngine.DESTINATION_NAME);
  String messageJSON=(String)jobDataMap.get(SchedulerEngine.MESSAGE);
  Message message=null;
  if (messageJSON == null) {
    message=new Message();
  }
 else {
    message=(Message)JSONFactoryUtil.deserialize(messageJSON);
  }
  String contextPath=message.getString(SchedulerEngine.CONTEXT_PATH);
  String lockKey=PortletContextLoaderListener.getLockKey(contextPath);
  ReentrantLock executionLock=null;
  if (lockKey != null) {
    executionLock=LockRegistry.getLock(lockKey,lockKey);
    if (executionLock != null) {
      if (executionLock.hasQueuedThreads()) {
        return;
      }
      executionLock.lock();
    }
  }
  try {
    message.put(SchedulerEngine.DESTINATION_NAME,destinationName);
    Scheduler scheduler=jobExecutionContext.getScheduler();
    Map<String,Object> jobStateMap=(Map<String,Object>)jobDataMap.get(SchedulerEngine.JOB_STATE);
    JobState jobState=JobStateSerializeUtil.deserialize(jobStateMap);
    if (jobExecutionContext.getNextFireTime() == null) {
      Trigger trigger=jobExecutionContext.getTrigger();
      StorageType storageType=StorageType.valueOf(jobDataMap.getString(SchedulerEngine.STORAGE_TYPE));
      if (storageType.equals(StorageType.PERSISTED)) {
        JobState jobStateClone=updatePersistedJobState(jobState,trigger);
        jobDataMap.put(SchedulerEngine.JOB_STATE,JobStateSerializeUtil.serialize(jobStateClone));
        scheduler.addJob(jobDetail,true);
      }
 else {
        message.put(SchedulerEngine.DISABLE,true);
        if (PropsValues.CLUSTER_LINK_ENABLED && storageType.equals(StorageType.MEMORY_CLUSTERED)) {
          notifyClusterMember(trigger.getJobName(),trigger.getGroup(),storageType);
        }
      }
    }
    message.put(SchedulerEngine.JOB_STATE,jobState);
    MessageBusUtil.sendMessage(destinationName,message);
  }
  finally {
    if (executionLock != null) {
      executionLock.unlock();
    }
  }
}
