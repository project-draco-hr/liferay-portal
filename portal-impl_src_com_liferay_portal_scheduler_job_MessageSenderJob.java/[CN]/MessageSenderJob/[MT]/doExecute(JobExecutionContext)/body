{
  JobDetail jobDetail=jobExecutionContext.getJobDetail();
  JobDataMap jobDataMap=jobDetail.getJobDataMap();
  String destinationName=jobDataMap.getString(SchedulerEngine.DESTINATION_NAME);
  String messageJSON=(String)jobDataMap.get(SchedulerEngine.MESSAGE);
  Message message=null;
  if (messageJSON == null) {
    message=new Message();
  }
 else {
    message=(Message)JSONFactoryUtil.deserialize(messageJSON);
  }
  message.put(SchedulerEngine.DESTINATION_NAME,destinationName);
  Scheduler scheduler=jobExecutionContext.getScheduler();
  SchedulerContext schedulerContext=scheduler.getContext();
  JobState jobState=(JobState)schedulerContext.get(jobDetail.getFullName());
  if (jobExecutionContext.getNextFireTime() == null) {
    Trigger trigger=jobExecutionContext.getTrigger();
    StorageType storageType=StorageType.valueOf(jobDataMap.getString(SchedulerEngine.STORAGE_TYPE));
switch (storageType) {
case PERSISTED:
      JobState jobStateClone=updatePersistedJobState(jobState,trigger);
    jobDataMap.put(SchedulerEngine.JOB_STATE,jobStateClone);
  scheduler.addJob(jobDetail,true);
break;
case MEMORY_SINGLE_INSTANCE:
if (PropsValues.CLUSTER_LINK_ENABLED) {
notifyClusterMember(storageType,trigger.getJobName(),trigger.getGroup());
}
case MEMORY_MULTIPLE_INSTANCES:
message.put(SchedulerEngine.DISABLE,true);
}
}
message.put(SchedulerEngine.JOB_STATE,jobState);
MessageBusUtil.sendMessage(destinationName,message);
}
