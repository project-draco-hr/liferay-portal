{
  JobDetail jobDetail=jobExecutionContext.getJobDetail();
  JobDataMap jobDataMap=jobDetail.getJobDataMap();
  String destinationName=jobDataMap.getString(SchedulerEngine.DESTINATION_NAME);
  String messageJSON=(String)jobDataMap.get(SchedulerEngine.MESSAGE);
  Message message=null;
  if (messageJSON == null) {
    message=new Message();
  }
 else {
    message=(Message)JSONFactoryUtil.deserialize(messageJSON);
  }
  message.put(SchedulerEngine.DESTINATION_NAME,destinationName);
  Scheduler scheduler=jobExecutionContext.getScheduler();
  JobState jobState=(JobState)jobDataMap.get(SchedulerEngine.JOB_STATE);
  if (jobExecutionContext.getNextFireTime() == null) {
    Trigger trigger=jobExecutionContext.getTrigger();
    StorageType storageType=StorageType.valueOf(jobDataMap.getString(SchedulerEngine.STORAGE_TYPE));
    if (storageType.equals(StorageType.PERSISTED)) {
      JobState jobStateClone=updatePersistedJobState(jobState,trigger);
      jobDataMap.put(SchedulerEngine.JOB_STATE,jobStateClone);
      scheduler.addJob(jobDetail,true);
    }
 else {
      message.put(SchedulerEngine.DISABLE,true);
      if (PropsValues.CLUSTER_LINK_ENABLED && storageType.equals(StorageType.MEMORY_SINGLE_INSTANCE)) {
        notifyClusterMember(trigger.getJobName(),trigger.getGroup(),storageType);
      }
    }
  }
  message.put(SchedulerEngine.JOB_STATE,jobState);
  MessageBusUtil.sendMessage(destinationName,message);
}
