{
  AtomicReference<DatagramReceiveHandler[]> datagramReceiveHandlersReference=_mockIntraband.datagramReceiveHandlersReference;
  DatagramReceiveHandler[] datagramReceiveHandlers=datagramReceiveHandlersReference.get();
  Assert.assertEquals(256,datagramReceiveHandlers.length);
  Assert.assertNotSame(datagramReceiveHandlers,_mockIntraband.getDatagramReceiveHandlers());
  DatagramReceiveHandler datagramReceiveHandler1=new RecordDatagramReceiveHandler();
  Assert.assertNull(_mockIntraband.registerDatagramReceiveHandler(_TYPE,datagramReceiveHandler1));
  Assert.assertSame(datagramReceiveHandler1,_mockIntraband.getDatagramReceiveHandlers()[_TYPE]);
  DatagramReceiveHandler datagramReceiveHandler2=new RecordDatagramReceiveHandler();
  Assert.assertSame(datagramReceiveHandler1,_mockIntraband.registerDatagramReceiveHandler(_TYPE,datagramReceiveHandler2));
  Assert.assertSame(datagramReceiveHandler2,_mockIntraband.getDatagramReceiveHandlers()[_TYPE]);
  Assert.assertSame(datagramReceiveHandler2,_mockIntraband.unregisterDatagramReceiveHandler(_TYPE));
  Assert.assertNull(_mockIntraband.getDatagramReceiveHandlers()[_TYPE]);
  final int inputDatagramReceiveHandlersCount=10240;
  final int threadCount=10;
  final DatagramReceiveHandler[] inputDatagramReceiveHandlers=new DatagramReceiveHandler[inputDatagramReceiveHandlersCount];
  for (int i=0; i < inputDatagramReceiveHandlersCount; i++) {
    inputDatagramReceiveHandlers[i]=new RecordDatagramReceiveHandler();
  }
  final Queue<DatagramReceiveHandler> outputDatagramReceiveHandlers=new ConcurrentLinkedQueue<DatagramReceiveHandler>();
class RegisterJob implements Callable<Void> {
    public RegisterJob(    int cur){
      int delta=inputDatagramReceiveHandlersCount / threadCount;
      _start=cur * delta;
      if ((_start + delta) > inputDatagramReceiveHandlersCount) {
        _end=inputDatagramReceiveHandlersCount;
      }
 else {
        _end=_start + delta;
      }
    }
    @Override public Void call(){
      for (int i=_start; i < _end; i++) {
        DatagramReceiveHandler outputDatagramReceiveHandler=_mockIntraband.registerDatagramReceiveHandler(_TYPE,inputDatagramReceiveHandlers[i]);
        if (outputDatagramReceiveHandler != null) {
          outputDatagramReceiveHandlers.offer(outputDatagramReceiveHandler);
        }
      }
      return null;
    }
    private final int _end;
    private final int _start;
  }
  List<RegisterJob> registerJobs=new ArrayList<>(threadCount);
  for (int i=0; i < threadCount; i++) {
    registerJobs.add(new RegisterJob(i));
  }
  ExecutorService executorService=Executors.newFixedThreadPool(threadCount);
  List<Future<Void>> futures=executorService.invokeAll(registerJobs);
  for (  Future<Void> future : futures) {
    future.get();
  }
  executorService.shutdownNow();
  outputDatagramReceiveHandlers.offer(_mockIntraband.getDatagramReceiveHandlers()[_TYPE]);
  Assert.assertEquals(inputDatagramReceiveHandlersCount,outputDatagramReceiveHandlers.size());
  for (  DatagramReceiveHandler inputDatagramReceiveHandler : inputDatagramReceiveHandlers) {
    Assert.assertTrue(outputDatagramReceiveHandlers.contains(inputDatagramReceiveHandler));
  }
  _mockIntraband.close();
  Assert.assertNull(datagramReceiveHandlersReference.get());
  try {
    _mockIntraband.getDatagramReceiveHandlers();
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
  try {
    _mockIntraband.registerDatagramReceiveHandler(_TYPE,new RecordDatagramReceiveHandler());
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
  try {
    _mockIntraband.unregisterDatagramReceiveHandler(_TYPE);
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
}
