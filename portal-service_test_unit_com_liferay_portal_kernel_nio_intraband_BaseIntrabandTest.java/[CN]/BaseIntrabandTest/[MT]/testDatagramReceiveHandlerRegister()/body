{
  AtomicReference<DatagramReceiveHandler[]> datagramReceiveHandlersReference=_mockIntraBand.datagramReceiveHandlersReference;
  DatagramReceiveHandler[] datagramReceiveHandlers=datagramReceiveHandlersReference.get();
  Assert.assertEquals(256,datagramReceiveHandlers.length);
  Assert.assertNotSame(datagramReceiveHandlers,_mockIntraBand.getDatagramReceiveHandlers());
  DatagramReceiveHandler datagramReceiveHandler1=new RecordDatagramReceiveHandler();
  Assert.assertNull(_mockIntraBand.registerDatagramReceiveHandler(_type,datagramReceiveHandler1));
  Assert.assertSame(datagramReceiveHandler1,_mockIntraBand.getDatagramReceiveHandlers()[_type]);
  DatagramReceiveHandler datagramReceiveHandler2=new RecordDatagramReceiveHandler();
  Assert.assertSame(datagramReceiveHandler1,_mockIntraBand.registerDatagramReceiveHandler(_type,datagramReceiveHandler2));
  Assert.assertSame(datagramReceiveHandler2,_mockIntraBand.getDatagramReceiveHandlers()[_type]);
  Assert.assertSame(datagramReceiveHandler2,_mockIntraBand.unregisterDatagramReceiveHandler(_type));
  Assert.assertNull(_mockIntraBand.getDatagramReceiveHandlers()[_type]);
  final int inputDatagramReceiveHandlersCount=10240;
  final int threadCount=10;
  final DatagramReceiveHandler[] inputDatagramReceiveHandlers=new DatagramReceiveHandler[inputDatagramReceiveHandlersCount];
  for (int i=0; i < inputDatagramReceiveHandlersCount; i++) {
    inputDatagramReceiveHandlers[i]=new RecordDatagramReceiveHandler();
  }
  final Queue<DatagramReceiveHandler> outputDatagramReceiveHandlers=new ConcurrentLinkedQueue<DatagramReceiveHandler>();
class RegisterJob implements Callable<Void> {
    public RegisterJob(    int cur){
      int delta=inputDatagramReceiveHandlersCount / threadCount;
      _start=cur * delta;
      if ((_start + delta) > inputDatagramReceiveHandlersCount) {
        _end=inputDatagramReceiveHandlersCount;
      }
 else {
        _end=_start + delta;
      }
    }
    public Void call(){
      for (int i=_start; i < _end; i++) {
        DatagramReceiveHandler outputDatagramReceiveHandler=_mockIntraBand.registerDatagramReceiveHandler(_type,inputDatagramReceiveHandlers[i]);
        if (outputDatagramReceiveHandler != null) {
          outputDatagramReceiveHandlers.offer(outputDatagramReceiveHandler);
        }
      }
      return null;
    }
    private final int _end;
    private final int _start;
  }
  List<RegisterJob> registerJobs=new ArrayList<RegisterJob>(threadCount);
  for (int i=0; i < threadCount; i++) {
    registerJobs.add(new RegisterJob(i));
  }
  ExecutorService executorService=Executors.newFixedThreadPool(threadCount);
  List<Future<Void>> futures=executorService.invokeAll(registerJobs);
  for (  Future<Void> future : futures) {
    future.get();
  }
  executorService.shutdownNow();
  outputDatagramReceiveHandlers.offer(_mockIntraBand.getDatagramReceiveHandlers()[_type]);
  Assert.assertEquals(inputDatagramReceiveHandlersCount,outputDatagramReceiveHandlers.size());
  for (  DatagramReceiveHandler inputDatagramReceiveHandler : inputDatagramReceiveHandlers) {
    Assert.assertTrue(outputDatagramReceiveHandlers.contains(inputDatagramReceiveHandler));
  }
  _mockIntraBand.close();
  Assert.assertNull(datagramReceiveHandlersReference.get());
  try {
    _mockIntraBand.getDatagramReceiveHandlers();
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
  try {
    _mockIntraBand.registerDatagramReceiveHandler(_type,new RecordDatagramReceiveHandler());
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
  try {
    _mockIntraBand.unregisterDatagramReceiveHandler(_type);
    Assert.fail();
  }
 catch (  ClosedIntrabandException cibe) {
  }
}
