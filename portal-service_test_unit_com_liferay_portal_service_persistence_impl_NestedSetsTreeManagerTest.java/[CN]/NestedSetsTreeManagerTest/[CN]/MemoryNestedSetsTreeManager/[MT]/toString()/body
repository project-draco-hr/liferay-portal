{
  StringBundler sb=new StringBundler(_simpleNestedSetsTreeNodeList.size() * 7);
  Collections.sort(_simpleNestedSetsTreeNodeList);
  Deque<SimpleNestedSetsTreeNode> deque=new LinkedList<SimpleNestedSetsTreeNode>();
  for (  SimpleNestedSetsTreeNode simpleNestedSetsTreeNode : _simpleNestedSetsTreeNodeList) {
    long nestedSetsTreeNodeLeft=simpleNestedSetsTreeNode.getNestedSetsTreeNodeLeft();
    long nestedSetsTreeNodeRight=simpleNestedSetsTreeNode.getNestedSetsTreeNodeRight();
    sb.append(StringPool.OPEN_PARENTHESIS);
    sb.append(nestedSetsTreeNodeLeft);
    sb.append(StringPool.POUND);
    sb.append(simpleNestedSetsTreeNode.getPrimaryKey());
    if ((nestedSetsTreeNodeLeft + 1) != nestedSetsTreeNodeRight) {
      deque.push(simpleNestedSetsTreeNode);
      continue;
    }
    sb.append(StringPool.COMMA_AND_SPACE);
    sb.append(nestedSetsTreeNodeRight);
    sb.append(StringPool.CLOSE_PARENTHESIS);
    SimpleNestedSetsTreeNode previousSimpleNestedSetsTreeNode=null;
    while (((previousSimpleNestedSetsTreeNode=deque.peek()) != null) && ((nestedSetsTreeNodeRight + 1) == previousSimpleNestedSetsTreeNode.getNestedSetsTreeNodeRight())) {
      sb.append(StringPool.COMMA_AND_SPACE);
      sb.append(previousSimpleNestedSetsTreeNode.getNestedSetsTreeNodeRight());
      sb.append(StringPool.CLOSE_PARENTHESIS);
      nestedSetsTreeNodeRight=previousSimpleNestedSetsTreeNode.getNestedSetsTreeNodeRight();
      deque.pop();
    }
  }
  return sb.toString();
}
