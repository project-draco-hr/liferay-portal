{
  StringBundler sb=new StringBundler(_simpleNestedSetsTreeNodes.size() * 7);
  Collections.sort(_simpleNestedSetsTreeNodes);
  Deque<SimpleNestedSetsTreeNode> deque=new LinkedList<SimpleNestedSetsTreeNode>();
  for (  SimpleNestedSetsTreeNode simpleNestedSetsTreeNode : _simpleNestedSetsTreeNodes) {
    long nestedSetsTreeNodeLeft=simpleNestedSetsTreeNode.getNestedSetsTreeNodeLeft();
    long nestedSetsTreeNodeRight=simpleNestedSetsTreeNode.getNestedSetsTreeNodeRight();
    sb.append(StringPool.OPEN_PARENTHESIS);
    sb.append(nestedSetsTreeNodeLeft);
    sb.append(StringPool.POUND);
    sb.append(simpleNestedSetsTreeNode.getPrimaryKey());
    if ((nestedSetsTreeNodeLeft + 1) != nestedSetsTreeNodeRight) {
      deque.push(simpleNestedSetsTreeNode);
      continue;
    }
    sb.append(StringPool.COMMA_AND_SPACE);
    sb.append(nestedSetsTreeNodeRight);
    sb.append(StringPool.CLOSE_PARENTHESIS);
    SimpleNestedSetsTreeNode previousNode=null;
    while (((previousNode=deque.peek()) != null) && ((nestedSetsTreeNodeRight + 1) == previousNode.getNestedSetsTreeNodeRight())) {
      sb.append(StringPool.COMMA_AND_SPACE);
      sb.append(previousNode.getNestedSetsTreeNodeRight());
      sb.append(StringPool.CLOSE_PARENTHESIS);
      nestedSetsTreeNodeRight=previousNode.getNestedSetsTreeNodeRight();
      deque.pop();
    }
  }
  return sb.toString();
}
