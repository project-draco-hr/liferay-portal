{
  try {
    _executorIntraBand.registerChannel(null,null);
    Assert.fail();
  }
 catch (  NullPointerException npe) {
    Assert.assertEquals("Gathering byte channel is null",npe.getMessage());
  }
  try {
    _executorIntraBand.registerChannel(null,IntraBandTestUtil.<GatheringByteChannel>createProxy(GatheringByteChannel.class));
    Assert.fail();
  }
 catch (  NullPointerException npe) {
    Assert.assertEquals("Scattering byte channel is null",npe.getMessage());
  }
  Pipe pipe=Pipe.open();
  SourceChannel sourceChannel=pipe.source();
  SinkChannel sinkChannel=pipe.sink();
  sourceChannel.configureBlocking(false);
  try {
    _executorIntraBand.registerChannel(sourceChannel,sinkChannel);
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Scattering byte channel is of type SelectableChannel and " + "configured in nonblocking mode",iae.getMessage());
  }
  sourceChannel.configureBlocking(true);
  sinkChannel.configureBlocking(false);
  try {
    _executorIntraBand.registerChannel(sourceChannel,sinkChannel);
  }
 catch (  IllegalArgumentException iae) {
    Assert.assertEquals("Gathering byte channel is of type SelectableChannel and " + "configured in nonblocking mode",iae.getMessage());
  }
  sourceChannel.configureBlocking(true);
  sinkChannel.configureBlocking(true);
  try {
    FutureRegistrationReference futureRegistrationReference=(FutureRegistrationReference)_executorIntraBand.registerChannel(sourceChannel,sinkChannel);
    Assert.assertSame(_executorIntraBand,futureRegistrationReference.getIntraBand());
    Assert.assertTrue(futureRegistrationReference.isValid());
    futureRegistrationReference.writeFuture.cancel(true);
    Assert.assertFalse(futureRegistrationReference.isValid());
    futureRegistrationReference.cancelRegistration();
    Assert.assertFalse(futureRegistrationReference.isValid());
    ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)_executorIntraBand.executorService;
    while (threadPoolExecutor.getActiveCount() != 0)     ;
  }
  finally {
    sourceChannel.close();
    sinkChannel.close();
  }
  File tempFile=new File("tempFile");
  tempFile.createNewFile();
  tempFile.deleteOnExit();
  FileInputStream fileInputStream=new FileInputStream(tempFile);
  FileOutputStream fileOutputStream=new FileOutputStream(tempFile);
  FileChannel readFileChannel=fileInputStream.getChannel();
  FileChannel writeFileChannel=fileOutputStream.getChannel();
  try {
    FutureRegistrationReference futureRegistrationReference=(FutureRegistrationReference)_executorIntraBand.registerChannel(readFileChannel,writeFileChannel);
    Assert.assertSame(_executorIntraBand,futureRegistrationReference.getIntraBand());
    Assert.assertTrue(futureRegistrationReference.isValid());
    futureRegistrationReference.writeFuture.cancel(true);
    Assert.assertFalse(futureRegistrationReference.isValid());
    futureRegistrationReference.cancelRegistration();
    Assert.assertFalse(futureRegistrationReference.isValid());
    ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)_executorIntraBand.executorService;
    while (threadPoolExecutor.getActiveCount() != 0)     ;
  }
  finally {
    readFileChannel.close();
    writeFileChannel.close();
  }
}
